## Q2. HTTPS 동작 과정에서 SSL/TLS 핸드셰이크는 어떻게 이루어지나요?

### 주요 키워드

- **SSL/TLS 핸드셰이크**: 클라이언트와 서버 간 보안 연결을 설정하는 과정
- **인증서 (Certificate)**: 서버의 신원을 증명하는 디지털 문서
- **대칭키 암호화 (Symmetric Encryption)**: 같은 키로 암호화/복호화하는 방식
- **비대칭키 암호화 (Asymmetric Encryption)**: 공개키/개인키 쌍을 사용하는 암호화 방식
- **세션키 (Session Key)**: 실제 데이터 암호화에 사용되는 대칭키
- **CA (Certificate Authority)**: 인증서를 발급하고 검증하는 신뢰기관
- **디지털 서명 (Digital Signature)**: 데이터 무결성과 인증을 보장하는 기술

### Script

SSL/TLS 핸드셰이크는 **클라이언트와 서버가 안전한 통신을 위해 암호화 방식을 협상하고 세션키를 교환하는 과정**입니다.

**첫 번째 단계는 ClientHello입니다.** 클라이언트가 서버에게 지원하는 TLS 버전, 암호화 알고리즘 목록(cipher suite), 랜덤 값을 전송합니다.

**두 번째로 ServerHello가 이어집니다.** 서버는 클라이언트가 제안한 암호화 알고리즘 중 하나를 선택하고, 서버의 랜덤 값과 함께 응답합니다. 그리고 서버는 자신의 인증서를 클라이언트에게 전송합니다.

**세 번째는 인증서 검증 과정입니다.** 클라이언트는 서버 인증서가 신뢰할 수 있는 CA에서 발급되었는지 확인하고, 인증서의 유효기간과 도메인 정보를 검증합니다.

**네 번째로 키 교환이 진행됩니다.** 클라이언트는 Pre-Master Secret을 생성하여 서버의 공개키로 암호화해서 전송합니다. 양쪽 모두 이 값과 앞서 교환한 랜덤 값들을 조합하여 동일한 Master Secret을 계산합니다.

**마지막으로 핸드셰이크 완료입니다.** 양쪽에서 Finished 메시지를 교환하여 핸드셰이크가 성공적으로 완료되었음을 확인하고, 이후부터는 협상된 세션키로 대칭키 암호화 통신을 시작합니다.

---

## HTTPS SSL/TLS 핸드셰이크

### 🔍 예상 꼬리 질문들

### Q2-1. "왜 처음부터 대칭키만 사용하지 않나요?"

**전문가 답변**:
**키 배송 문제(Key Distribution Problem)** 때문입니다.

대칭키 암호화는 연산 속도가 빠르지만, 통신 당사자 간에 동일한 비밀키를 사전에 안전하게 공유해야 한다는 근본적인 문제가 있습니다. 네트워크상에서 처음 만나는 클라이언트와 서버가 안전한 채널 없이 대칭키를 교환하는 것은 불가능합니다.

따라서 **공개키가 노출되어도 안전한 비대칭키 암호화**로 초기 키 교환을 수행하고, 이후 성능상 이점이 있는 대칭키로 전환하는 **하이브리드 암호 시스템**을 사용합니다.

---

### Q2-2. "인증서 검증 과정에서 중간자 공격을 어떻게 방지하나요?"

**전문가 답변**:
**PKI(Public Key Infrastructure) 기반의 신뢰 체인**을 통해 방지합니다.

클라이언트는 서버로부터 받은 인증서를 다음과 같이 검증합니다:

1. **인증서 체인 검증**: 서버 인증서 → 중간 CA → 루트 CA로 이어지는 신뢰 체인 확인
2. **디지털 서명 검증**: 상위 CA의 공개키로 하위 인증서의 서명을 암호학적으로 검증
3. **도메인 검증**: 인증서의 CN(Common Name) 또는 SAN(Subject Alternative Name)이 접속 도메인과 일치하는지 확인
4. **유효기간 및 폐기 상태**: OCSP 또는 CRL을 통한 인증서 폐기 여부 확인

공격자가 가짜 인증서를 제시해도 신뢰할 수 있는 CA의 서명이 없으면 검증에 실패합니다.

---

### Q2-3. "TLS 1.2와 TLS 1.3의 핸드셰이크 차이점은?"

**전문가 답변**:
**라운드트립 횟수와 보안성**에서 크게 개선되었습니다.

**TLS 1.2**: 2-RTT 핸드셰이크

- ClientHello → ServerHello, Certificate, ServerKeyExchange, ServerHelloDone
- ClientKeyExchange, ChangeCipherSpec, Finished → ChangeCipherSpec, Finished

**TLS 1.3**: 1-RTT 핸드셰이크

- ClientHello(키 교환 매개변수 포함) → ServerHello, EncryptedExtensions, Certificate, Finished
- Finished →

**주요 개선사항**:

- **지연시간 50% 단축**: 1-RTT로 연결 설정
- **0-RTT 재개**: PSK 기반으로 첫 요청과 함께 애플리케이션 데이터 전송 가능
- **보안 강화**: RSA 키 교환, 약한 cipher suite 제거로 Perfect Forward Secrecy 보장

---

### Q2-4. "Perfect Forward Secrecy(PFS)가 왜 중요한가요?"

**전문가 답변**:
**장기 비밀키 노출로부터 과거 세션을 보호**하기 위해서입니다.

**RSA 키 교환의 취약점**:

- 서버의 RSA 개인키가 노출되면 과거에 녹화된 모든 암호화 통신을 복호화 가능
- 공격자가 "store now, decrypt later" 전략으로 암호화된 트래픽을 저장해두었다가 추후 키 노출 시 모든 내용 해독

**ECDHE의 해결책**:

- **임시 키 쌍(Ephemeral Key Pair)** 사용으로 세션마다 새로운 키 생성
- 세션 종료 후 개인키 즉시 삭제
- 현재 세션 키가 노출되어도 과거/미래 세션에는 영향 없음

현재 주요 웹사이트들은 모두 ECDHE 기반 키 교환을 사용하여 PFS를 보장합니다.
