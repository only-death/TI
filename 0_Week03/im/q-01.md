# 토픽: HTTP, 프로토콜, 네트워크

## Q1. HTTP/1.1과 HTTP/2의 주요 차이점은 무엇인가요?

### 주요 키워드

- **멀티플렉싱 (Multiplexing)**: 하나의 연결에서 여러 요청을 동시에 처리하는 기법
- **헤더 압축 (Header Compression)**: HPACK을 사용하여 헤더 크기를 줄이는 기술
- **서버 푸시 (Server Push)**: 클라이언트 요청 전에 서버가 리소스를 미리 전송하는 기능
- **바이너리 프로토콜 (Binary Protocol)**: 텍스트 대신 바이너리 형태로 데이터 전송
- **스트림 우선순위 (Stream Prioritization)**: 중요한 리소스에 우선순위를 부여하는 기능
- **HOL Blocking**: Head-of-Line Blocking, 앞선 요청이 지연되면 뒤의 요청도 지연되는 현상

### Script

HTTP/1.1과 HTTP/2의 가장 큰 차이점은 **멀티플렉싱 지원**입니다.

**HTTP/1.1의 한계점을 보면**, 하나의 TCP 연결에서 한 번에 하나의 요청만 처리할 수 있어 HOL Blocking 문제가 발생합니다. 이를 해결하기 위해 브라우저는 도메인당 여러 개의 연결을 맺지만 연결 수에 제한이 있고, 각 연결마다 핸드셰이크 오버헤드가 발생합니다.

**HTTP/2는 이런 문제들을 근본적으로 해결합니다.** 먼저 멀티플렉싱을 통해 하나의 TCP 연결에서 여러 요청을 동시에 처리할 수 있어 HOL Blocking이 해결됩니다. 또한 HPACK 압축 알고리즘으로 헤더 크기를 크게 줄이고, 바이너리 프로토콜 사용으로 파싱 효율성이 향상됩니다.

**서버 푸시 기능**도 HTTP/2의 특징인데, 클라이언트가 HTML을 요청하면 서버가 필요할 CSS, JS 파일들을 미리 전송할 수 있어 페이지 로딩 시간이 단축됩니다.

**성능상 HTTP/2는** 특히 많은 리소스를 가진 웹페이지에서 현저한 성능 향상을 보여주며, 연결 수 제한으로 인한 병목현상이 해결됩니다.

---

## HTTP/1.1과 HTTP/2 차이점

### 🔍 예상 꼬리 질문들

### Q1-1. "그럼 HTTP/2에서 HOL Blocking이 완전히 해결되었나요?"

**답변**: 아니요, **HTTP/2는 HTTP 레벨에서만 HOL Blocking을 해결**했습니다. 하지만 **TCP 레벨에서는 여전히 HOL Blocking이 존재**합니다. HTTP/2는 하나의 TCP 연결을 사용하는데, TCP 패킷이 손실되면 그 패킷이 재전송될 때까지 모든 HTTP/2 스트림이 대기해야 합니다. 이것이 HTTP/3에서 UDP 기반의 QUIC 프로토콜을 사용하는 이유입니다.

### Q1-2. "멀티플렉싱이 가능하다면 브라우저의 동시 연결 수 제한이 의미가 없어지나요?"

**답변**: 맞습니다. HTTP/2에서는 **하나의 TCP 연결로 모든 요청을 처리**할 수 있어서, 브라우저의 도메인당 6-8개 연결 제한이 실질적으로 의미가 없어집니다. 대신 **하나의 연결에서 동시에 처리할 수 있는 스트림 수 제한**이 더 중요해집니다. 기본적으로 100개의 동시 스트림을 지원합니다.

### Q1-3. "HPACK 압축은 어떤 원리로 헤더를 압축하나요?"

**답변**: HPACK은 **두 가지 압축 기법**을 사용합니다:

1. **정적 테이블**: 자주 사용되는 헤더 필드들을 미리 정의된 인덱스로 참조
2. **동적 테이블**: 연결 과정에서 사용된 헤더들을 저장하고 재사용

예를 들어 `:method: GET`은 인덱스 2번으로 참조하고, 이전에 보낸 `user-agent` 헤더가 있다면 인덱스로만 참조해서 크기를 크게 줄입니다.

### Q1-4. "서버 푸시가 항상 성능 향상을 가져오나요?"

**답변**: 아니요. 서버 푸시는 **잘못 사용하면 오히려 성능 저하**를 일으킬 수 있습니다:

- 클라이언트가 이미 캐시에 가지고 있는 리소스를 푸시하면 대역폭 낭비
- 클라이언트가 실제로 필요하지 않은 리소스를 푸시하면 불필요한 트래픽 발생
- 실제로 많은 CDN들이 서버 푸시를 비활성화하고 있으며, **HTTP/3에서는 서버 푸시가 제거**되었습니다.

### Q1-5. "HTTP/2 환경에서는 리소스 최적화 전략이 어떻게 달라져야 하나요?"

**답변**: HTTP/2에서는 기존 최적화 전략을 **재검토**해야 합니다:

**변경이 필요한 것들**:

- **파일 결합(concatenation)**: 여러 CSS/JS 파일을 하나로 합치는 것이 불필요
- **도메인 샤딩**: 여러 도메인 사용이 오히려 성능 저하
- **CSS 스프라이트**: 작은 이미지들을 합치는 것보다 개별 파일이 나을 수 있음

**여전히 유효한 것들**:

- **파일 압축 (gzip, brotli)**
- **이미지 최적화**
- **캐싱 전략**

### Q1-6. "바이너리 프로토콜의 단점은 없나요?"

**답변**: 바이너리 프로토콜의 주요 단점은 **디버깅의 어려움**입니다:

- HTTP/1.1은 텍스트 기반이라 **와이어샤크 같은 도구로 쉽게 분석** 가능
- HTTP/2는 바이너리라 **전용 도구나 브라우저 개발자 도구**가 필요
- 하지만 성능상 이점이 훨씬 크기 때문에 대부분의 경우 장점이 단점을 상회합니다.

### Q1-7. "HTTP/2가 모든 환경에서 HTTP/1.1보다 빠른가요?"

**답변**: 아니요. **네트워크 환경과 웹사이트 특성**에 따라 다릅니다:

**HTTP/2가 더 유리한 경우**:

- 많은 리소스를 가진 웹페이지
- 높은 지연시간(latency) 네트워크
- 모던 브라우저 환경

**HTTP/1.1이 나을 수 있는 경우**:

- 매우 단순한 웹페이지 (리소스가 적음)
- 네트워크 패킷 손실이 많은 환경 (TCP HOL Blocking)
- 매우 오래된 프록시나 방화벽 환경

### Q1-8. "스트림 우선순위는 실제로 어떻게 활용되나요?"

**답변**: 스트림 우선순위는 **중요한 리소스를 먼저 전송**하기 위해 사용됩니다:

- **HTML 문서**: 가장 높은 우선순위
- **CSS**: 렌더링에 필요하므로 높은 우선순위
- **JavaScript**: 중간 우선순위
- **이미지**: 상대적으로 낮은 우선순위

하지만 실제로는 **브라우저마다 구현이 다르고**, 서버에서도 완벽하게 지원하지 않는 경우가 많아 기대만큼 효과를 보지 못하는 경우가 있습니다.

---

## 💡 핵심 포인트 정리

1. **HTTP/2의 가장 큰 장점**: 멀티플렉싱으로 인한 동시 요청 처리
2. **여전한 한계**: TCP 레벨 HOL Blocking은 해결 안 됨
3. **최적화 전략 변화**: 기존 번들링/결합 전략 재검토 필요
4. **환경별 성능**: 모든 상황에서 항상 빠른 것은 아님
5. **미래 방향**: HTTP/3로의 진화 (QUIC 프로토콜 기반)
