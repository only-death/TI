# 토픽: Webpack

## Q. Vite와 Webpack의 차이점은?

### 주요 키워드

- **Vite**: 네이티브 ES 모듈과 esbuild를 활용한 빠른 프론트엔드 빌드 도구
- **Webpack**: 정적 모듈 번들러로 모든 자산을 하나 이상의 번들로 결합
- **ES 모듈 (ES Modules, ESM)**: 브라우저의 네이티브 모듈 시스템
- **콜드 스타트 (Cold Start)**: 개발 서버 초기 구동 시간
- **핫 모듈 교체 (Hot Module Replacement, HMR)**: 개발 중 실시간 모듈 업데이트
- **esbuild**: Go로 작성된 고성능 JavaScript 번들러 및 트랜스파일러
- **Rollup**: Vite의 프로덕션 빌드에 사용되는 ES 모듈 최적화 번들러
- **의존성 사전 번들링 (Dependency Pre-bundling)**: 의존성을 미리 번들링하여 성능 최적화
- **번들 기반 개발 서버**: 모든 파일을 번들링한 후 서빙하는 전통적 방식
- **네이티브 ESM 개발 서버**: 브라우저의 ES 모듈 지원을 직접 활용하는 방식

### Script

Vite와 Webpack은 **개발 철학과 접근 방식에서 근본적인 차이**를 보입니다. 웹팩은 정적 모듈 번들러로서 애플리케이션을 처리할 때 하나 이상의 엔트리 포인트에서 의존성 그래프를 내부적으로 구축하고 프로젝트에 필요한 모든 모듈을 하나 이상의 번들로 결합합니다.

**가장 큰 차이점은 개발 서버 구동 방식입니다.** 번들러 기반 빌드 설정에서 개발 서버를 콜드 스타트할 때, 번들러는 서빙하기 전에 전체 애플리케이션을 미리 크롤링하고 빌드해야 합니다. 반면 Vite는 애플리케이션의 모듈을 의존성과 소스 코드 두 카테고리로 나누어 개발 서버 시작 시간을 개선합니다.

**의존성 처리에서도 전략이 다릅니다.** Vite는 esbuild를 사용하여 의존성을 사전 번들링하는데, esbuild는 Go로 작성되어 JavaScript 기반 번들러보다 10-100배 빠르게 의존성을 사전 번들링합니다. 한편 Vite는 네이티브 ESM을 통해 소스 코드를 서빙하여 브라우저가 번들러의 일부 작업을 대신하게 하고, 브라우저가 요청할 때만 온디맨드로 소스 코드를 변환하고 제공합니다.

**HMR 성능에서도 명확한 차이가 있습니다.** 번들러 기반 빌드 설정에서 파일이 편집되면 전체 번들을 재구성하는 것은 비효율적이며, 앱 크기에 따라 업데이트 속도가 선형적으로 저하됩니다. 반면 Vite에서는 네이티브 ESM을 통해 HMR이 수행되어 파일 편집 시 편집된 모듈과 가장 가까운 HMR 경계 사이의 체인만 정확히 무효화하면 되므로 애플리케이션 크기에 관계없이 일관되게 빠른 HMR 업데이트가 가능합니다.

**프로덕션 빌드에서는 두 도구 모두 최적화를 제공합니다.** 네이티브 ESM이 널리 지원되더라도 중첩된 임포트로 인한 추가 네트워크 라운드트립 때문에 프로덕션에서 번들되지 않은 ESM을 출시하는 것은 여전히 비효율적입니다. Vite는 프로덕션을 위해 Rollup을 사용하여 최적화된 빌드를 제공하며, Webpack도 다양한 최적화 기능을 통해 효율적인 프로덕션 번들을 생성합니다.

**생태계와 성숙도 측면에서는** 웹팩은 2012년부터 존재해 왔으며 자연스럽게 더 큰 커뮤니티, 성숙한 플러그인 생태계, 다양한 주제에 대한 광범위한 문서를 보유하고 있습니다. Vite는 상대적으로 새롭고 2020년에 데뷔했지만 사용자 커뮤니티가 빠르게 성장하고 있습니다.

### 추가 학습내용

#### **Vite 심화 개념**

1. **의존성 사전 번들링**: esbuild를 통한 CommonJS/UMD 모듈의 ESM 변환 과정
2. **Vite 플러그인 시스템**: Rollup 플러그인 API 기반의 개발/빌드 통합 방식
3. **Rolldown 프로젝트**: Rust로 작성된 차세대 번들러와 Vite의 미래 로드맵
4. **네이티브 ESM 최적화**: HTTP 헤더를 활용한 캐싱 전략과 성능 최적화

#### **Webpack 고급 기능**

5. **Module Federation**: 마이크로 프론트엔드를 위한 런타임 모듈 공유 시스템
6. **웹팩 5 캐싱**: 파일시스템 기반 영구 캐싱과 빌드 성능 최적화
7. **의존성 그래프 최적화**: 정적 분석을 통한 번들 크기 최적화 전략
8. **커스텀 로더와 플러그인**: 복잡한 빌드 요구사항을 위한 확장 개발

#### **마이그레이션 및 선택 기준**

9. **Webpack에서 Vite 마이그레이션**: 기존 프로젝트 이전 시 고려사항과 단계별 접근법
10. **프로젝트 규모별 선택 기준**: 소규모 vs 엔터프라이즈 프로젝트에서의 도구 선택
11. **레거시 브라우저 지원**: 폴리필과 트랜스파일레이션 전략 비교
12. **모노레포 지원**: Nx, Lerna와 함께 사용하는 빌드 도구 최적화

#### **성능 및 최적화**

13. **빌드 시간 벤치마크**: 프로젝트 규모별 성능 비교와 측정 방법론
14. **번들 크기 최적화**: 트리 셰이킹과 코드 스플리팅 전략 비교
15. **개발자 경험 개선**: HMR, 오류 처리, 디버깅 도구 비교 분석

---

### 정리

**개발 서버 차이점**

- **Vite**: 네이티브 ESM 활용, 즉시 시작, esbuild 사전 번들링
- **Webpack**: 전체 앱 번들링 후 서빙, 의존성 그래프 기반 처리

**HMR 성능**

- **Vite**: 모듈별 정밀 업데이트, 앱 크기 무관한 일정한 속도
- **Webpack**: 전체 번들 재구성, 앱 크기에 따른 성능 저하

**프로덕션 빌드**

- **Vite**: Rollup 기반, ES 모듈 최적화, 간단한 설정
- **Webpack**: 고도로 설정 가능, 풍부한 플러그인, 복잡한 최적화

**생태계 및 성숙도**

- **Vite**: 2020년 출시, 빠른 성장, 모던 프론트엔드 중심
- **Webpack**: 2012년부터, 성숙한 생태계, 광범위한 문서와 플러그인

**적합한 사용 사례**

- **Vite**: 새 프로젝트, 빠른 개발 경험 중시, 모던 브라우저 타겟
- **Webpack**: 복잡한 설정 필요, 레거시 지원, 대규모 엔터프라이즈 프로젝트
