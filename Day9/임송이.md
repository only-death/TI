# 1. 데이터베이스 정규화에 대해 설명해주세요.

## 중요 키워드

- 데이터 중복 제거
- 데이터 무결성
- 함수적 종속성
- 1NF, 2NF, 3NF, BCNF (ex: 1NF: First Normal Form)
- 역정규화(Denormalization): 쿼리 성능을 위해 정규화 무시

## Script

데이터베이스 정규화는 데이터 중복(data redundancy)을 최소화하고 데이터 무결성(data integrity)을 보장하기 위해 관계형 데이터베이스의 설계를 체계적으로 구성하는 프로세스입니다. 주로 테이블을 분해하여 데이터의 중복을 제거하고 종속성(dependency)을 관리합니다.

정규화는 여러 단계(정규형)로 진행됩니다:

1. **제1정규형(1NF)**: 테이블의 각 셀은 단일 값 (원자적값)만 가지며, 같은 종류의 데이터가 여러 열에 반복되지 않아야 합니다. 테이블의 각 속성은 primary key를 사용하여 찾을 수 있어야 합니다.

2. **제2정규형(2NF)**: 1NF를 만족하며, 모든 비주요(Non-Prime Attribute) 속성이 Primary Key에 완전 함수적 종속이어야 합니다. 부분적 종속성(Partial dependency)을 제거합니다.

3. **제3정규형(3NF)**: 2NF를 만족하며, 비주요 속성이 다른 비주요 속성에 종속되지 않아야 합니다. 이행적 종속성(Transitive dependency)을 제거합니다.

4. **BCNF(Boyce-Codd 정규형)**: 3NF의 강화된 형태로, 모든 결정자(Determinant)가 후보키(Candidate key)여야 합니다.

5. **제4정규형(4NF)**: BCNF의 모든 조건을 만족하고, 다치 종속성(Multi-valued dependency)이 없어야 합니다. 하나의 속성이 여러개의 독립적인 다치 속성을 결정한다면, 별도의 테이블로 분리 되어야 합니다.

6. **제5정규형(5NF)**: 4NF를 만족하며, 조인 종속성(Join dependency)이 없어야 합니다. 즉, 테이블이 더 작은 테이블들로 손실 없이 분해될 수 없어야 합니다.

실무에서는 일반적으로 3NF나 BCNF까지 정규화를 진행합니다. 그러나 쿼리 성능(query performance)을 고려해 의도적으로 역정규화(denormalization)를 적용할 수도 있습니다. 역정규화는 특정 조건에서 성능을 향상시키기 위해 정규화 원칙을 완화하는 것입니다.
예를 들어, 자주 조회되는 데이터의 경우 여러 테이블을 join(조인)하는 대신 일부 정보를 중복 저장하여 조회 성능을 향상시킬 수 있습니다. 이렇게 데이터 무결성과 쿼리 성능 사이의 균형을 찾는 것이 중요합니다.

### 정리

**정의**: 데이터베이스 정규화는 데이터 중복을 최소화하고 무결성을 보장하기 위한 테이블 구조화 프로세스

**주요 정규형**:

- 1NF: 각 열은 단일 값만 가짐, 반복 그룹 없음
- 2NF: 부분 종속성 제거 (모든 비주요 속성이 기본키에 완전 종속)
- 3NF: 이행적 종속성 제거 (비주요 속성이 다른 비주요 속성에 종속되지 않음)
- BCNF: 모든 결정자가 후보키여야 함
- 4NF: 다치 속성 제거
- 5NF: 조인 종속성 제거

**장점**:

- 데이터 중복 최소화로 저장 공간 절약
- 데이터 일관성과 무결성 향상
- 구조 변경에 유연하게 대응 가능

**고려사항**:

- 정규화가 높을수록 JOIN 연산 증가로 성능 저하 가능
- 필요시 역정규화로 성능 최적화

## 더 알아야할 내용

### Q. 언제 역정규화를 고려해야 하나요?

읽기 작업이 많고 자주 조인이 필요한 경우, 성능이 중요한 경우에 고려합니다. 예를 들어 실시간 분석 대시보드, 자주 접근하는 보고서 등에 적용합니다.

- 읽기 작업이 대부분인 시스템
- 실시간 집계가 필요한 대시보드
- 자주 조인되는 테이블의 특정 컬럼 복제
- 계산 비용이 높은 집계 값 저장

### Q. 정규화와 인덱싱의 관계는 무엇인가요?

정규화된 테이블은 더 효율적인 인덱싱이 가능합니다. 중복이 줄어 인덱스 크기가 작아지고, 갱신 비용이 감소합니다.

### Q. NoSQL 데이터베이스에서도 정규화가 필요한가요?

NoSQL은 비정규화된 구조를 허용하지만, 데이터 중복과 일관성 문제는 여전히 고려해야 합니다. 용도에 맞게 적절한 데이터 모델링이 필요합니다.

## 질문 의도

정규화 개념 이해와 실무 적용 능력, 성능과 데이터 무결성 사이의 균형을 판단하는 능력 평가

---

### Terminology

# 데이터베이스 정규화 용어 정리 (Database Normalization Terminology)

## 핵심 개념 용어

### 키(Key) 관련 용어

- **Super Key (슈퍼키)**: 테이블에서 각 행을 **유일하게 식별**할 수 있는 하나 또는 그 이상의 속성 집합입니다. 최소성을 만족할 필요는 없습니다. 예: {학번 + 이름}, {주민등록번호 + 학번}
- **Candidate Key (후보키)**: **유일성**과 **최소성**을 모두 만족하는 키입니다. 즉, 테이블의 각 행을 고유하게 식별할 수 있으면서 더 이상 줄일 수 없는 최소한의 속성 집합입니다. 기본키가 될 수 있는 후보들이기 때문에 후보키라고 불립니다. 예: 주민등록번호, 학번
- **Primary Key (기본키)**: 후보키 중에서 선택된 하나의 키로, 테이블에서 **오직 1개**만 지정할 수 있습니다. **NULL 값을 가질 수 없으며**, 중복된 값도 가질 수 없습니다.
- **Alternate Key (대체키)**: 후보키가 두 개 이상일 경우, 그 중에서 기본키로 선택되지 않은 나머지 후보키들을 말합니다. 기본키가 없어지면 대체키가 기본키를 대체할 수 있습니다.
- **Composite Key (복합키)**: 두 개 이상의 속성(attribute)으로 구성된 키입니다. 여러 속성을 조합해야 각 행을 유일하게 식별할 수 있는 경우에 사용됩니다.
- **Foreign Key (외래키)**: 다른 테이블의 Primary Key를 참조하는 속성입니다. 테이블 간의 관계를 정의하는 데 사용됩니다. 참조되는 테이블은 부모 테이블, 참조하는 테이블은 자식 테이블이라고 합니다.

```text

┌───────────────────── Super Key (슈퍼키) ───────────────────────┐
│                                                              │
│  ┌─────────── Candidate Key (후보키) ─────────────┐            │
│  │          (선택 시)                (선택 안됨)    │            │
│  │   ┌──── Primary Key ─────┐  ┌── Alternate ──┐│            │
│  │   │      (기본키)          │  │  Key(대체키)   ││            │
│  │   └──────────────────────┘  └───────────────┘│            │
│  │                                              │            │
│  └──────────────────────────────────────────────┘            │
│                                                              │
└──────────────────────────────────────────────────────────────┘

    ┌─────── Composite Key ──────┐     ┌───── Foreign Key ─────┐
    │         (복합키)             │     │       (외래키)         │
    │                            │     │                       │
    │  (Super Key, Candidate Key,│     │  (다른 테이블의          │
    │   Primary Key 모두가 될      │     │   Primary Key를 참조)   │
    │   수 있음)                   │     │                       │
    └────────────────────────────┘     └───────────────────────┘


```

### 속성(Attribute) 관련 용어

- **Prime Attribute (주요 속성)**: 어떤 Candidate Key에 포함되는 속성입니다.
- **Non-Prime Attribute (비주요 속성)**: 어떤 Candidate Key에도 포함되지 않는 속성입니다.
- **Atomic Value (원자적 값)**: 더 이상 분할할 수 없는 단일 값입니다. 1NF에서는 모든 속성이 원자적 값만 가져야 합니다.

### 종속성(Dependency) 관련 용어

- **Functional Dependency (함수적 종속성)**: 속성 A가 속성 B를 확정하는 관계로, A → B로 표기합니다. A의 값이 결정되면 B의 값도 유일하게 결정됩니다.
- **Determinant (결정자)**: Functional Dependency에서 다른 속성의 값을 확정하는 속성입니다.
- **Full Functional Dependency (완전 함수적 종속성)**: 복합 키 전체가 다른 속성을 확정하는 관계입니다. 복합 키의 일부만으로는 그 속성을 확정할 수 없습니다.
- **Partial Dependency (부분 종속성)**: 복합 키의 일부만으로 다른 속성을 확정할 수 있는 관계입니다. 2NF에서는 이러한 부분 종속성을 제거해야 합니다.
- **Transitive Dependency (이행적 종속성)**: A → B이고 B → C이면, A → C인 관계입니다. 비주요 속성이 다른 비주요 속성을 결정하는 관계입니다. 3NF에서는 이를 제거해야 합니다.
- **Multi-valued Dependency (다치 종속성)**: 하나의 속성이 여러 개의 독립적인 다치 속성을 결정하는 관계입니다. 4NF에서는 이를 제거해야 합니다.
- **Join Dependency (조인 종속성)**: 테이블이 손실 없이 여러 작은 테이블로 분해될 수 있는 성질입니다. 5NF에서는 이를 제거해야 합니다.

## 기타 중요 용어

- **Normalization (정규화)**: 데이터 중복을 최소화하고 데이터 무결성을 보장하기 위해 데이터베이스를 구조화하는 과정입니다.
- **Denormalization (역정규화)**: 쿼리 성능 향상을 위해 의도적으로 정규화 규칙을 완화하는 과정입니다.
- **Data Redundancy (데이터 중복)**: 동일한 데이터가 여러 위치에 저장되는 상황입니다.
- **Data Integrity (데이터 무결성)**: 데이터의 정확성과 일관성을 유지하는 것입니다.
- **Anomaly (이상 현상)**: 데이터베이스 조작 시 발생할 수 있는 문제점으로, 삽입 이상(Insertion Anomaly), 삭제 이상(Deletion Anomaly), 갱신 이상(Update Anomaly)이 있습니다.
- **Repeating Group (반복 그룹)**: 하나의 레코드 내에서 유사한 데이터가 여러 열로 반복되는 구조입니다. 1NF에서는 이를 제거해야 합니다.

---

# 데이터베이스 정규화 단계별 예시

## 시작 테이블 (비정규화 상태)

아래는 학생들의 수강 과목과 교수 정보를 담은 비정규화된 테이블입니다:

| 학번 | 학생이름 | 과목코드 | 과목명         | 학점 | 교수ID | 교수이름 | 학과       |
| ---- | -------- | -------- | -------------- | ---- | ------ | -------- | ---------- |
| 1001 | 김철수   | CS101    | 프로그래밍기초 | 3    | P01    | 박교수   | 컴퓨터공학 |
| 1001 | 김철수   | CS102    | 자료구조       | 3    | P02    | 이교수   | 컴퓨터공학 |
| 1002 | 이영희   | CS101    | 프로그래밍기초 | 3    | P01    | 박교수   | 컴퓨터공학 |
| 1002 | 이영희   | MATH101  | 미적분학       | 4    | P03    | 최교수   | 수학       |
| 1003 | 박지민   | MATH101  | 미적분학       | 4    | P03    | 최교수   | 수학       |

## 제1정규형(1NF)

위 테이블은 이미 1NF를 만족합니다:

- 각 셀에는 단일 값만 있음
- 같은 종류의 데이터가 여러 열에 반복되지 않음
- 모든 속성이 원자적(atomic) 값을 가짐

## 제2정규형(2NF)

2NF는 부분 종속성을 제거합니다. 현재 테이블에서 기본 키는 (학번, 과목코드)의 복합 키입니다.

### 부분 종속성 식별:

- 학생이름은 학번에만 종속 (학번 → 학생이름)
- 과목명, 학점은 과목코드에만 종속 (과목코드 → 과목명, 학점)
- 교수이름, 학과는 교수ID에만 종속 (교수ID → 교수이름, 학과)

### 2NF로 분해:

**수강 테이블** (PK: 학번, 과목코드)
| 학번 | 과목코드 | 교수ID |
|------|----------|--------|
| 1001 | CS101 | P01 |
| 1001 | CS102 | P02 |
| 1002 | CS101 | P01 |
| 1002 | MATH101 | P03 |
| 1003 | MATH101 | P03 |

**학생 테이블** (PK: 학번)
| 학번 | 학생이름 |
|------|----------|
| 1001 | 김철수 |
| 1002 | 이영희 |
| 1003 | 박지민 |

**과목 테이블** (PK: 과목코드)
| 과목코드 | 과목명 | 학점 |
|----------|--------|------|
| CS101 | 프로그래밍기초 | 3 |
| CS102 | 자료구조 | 3 |
| MATH101 | 미적분학 | 4 |

**교수 테이블** (PK: 교수ID)
| 교수ID | 교수이름 | 학과 |
|--------|----------|------|
| P01 | 박교수 | 컴퓨터공학 |
| P02 | 이교수 | 컴퓨터공학 |
| P03 | 최교수 | 수학 |

## 제3정규형(3NF)

3NF는 이행적 종속성을 제거합니다.

### 이행적 종속성 식별:

- 수강 테이블에는 이행적 종속성이 없음
- 학생 테이블에는 이행적 종속성이 없음
- 과목 테이블에는 이행적 종속성이 없음
- 교수 테이블에서 가능한 이행적 종속성: 교수ID → 학과 → 학과장(만약 학과장 정보가 있다면)

위 테이블들은 이미 3NF를 만족합니다. 이행적 종속성의 예를 들기 위해 추가 속성을 가정해보겠습니다:

**교수 테이블 (이행적 종속성 있음)**
| 교수ID | 교수이름 | 학과 | 학과장 | 학과사무실 |
|--------|----------|------|--------|------------|
| P01 | 박교수 | 컴퓨터공학 | 장교수 | 공학관 301호 |
| P02 | 이교수 | 컴퓨터공학 | 장교수 | 공학관 301호 |
| P03 | 최교수 | 수학 | 정교수 | 과학관 201호 |

여기서 이행적 종속성: 교수ID → 학과 → 학과장, 학과사무실
(교수ID로 학과를 알 수 있고, 학과로 학과장과 학과사무실을 알 수 있음)

### 3NF로 분해:

**교수 테이블** (3NF)
| 교수ID | 교수이름 | 학과 |
|--------|----------|------|
| P01 | 박교수 | 컴퓨터공학 |
| P02 | 이교수 | 컴퓨터공학 |
| P03 | 최교수 | 수학 |

**학과 테이블** (3NF)
| 학과 | 학과장 | 학과사무실 |
|------|--------|------------|
| 컴퓨터공학 | 장교수 | 공학관 301호 |
| 수학 | 정교수 | 과학관 201호 |

## BCNF (Boyce-Codd 정규형)

BCNF는 모든 결정자가 후보 키여야 한다는 조건입니다. 위의 테이블들은 이미 BCNF를 만족합니다.

BCNF 위반의 예를 들기 위해 다음과 같은 상황을 가정해봅시다:

**과목개설 테이블** (3NF이지만 BCNF 아님)
| 과목코드 | 교수ID | 학기 | 강의실 |
|----------|--------|------|--------|
| CS101 | P01 | 2023-1 | 공학관 110호 |
| CS102 | P02 | 2023-1 | 공학관 120호 |
| MATH101 | P03 | 2023-1 | 과학관 220호 |
| CS101 | P04 | 2023-2 | 공학관 110호 |

이 테이블에서:

- 기본 키: (과목코드, 교수ID, 학기)
- 함수적 종속성: (교수ID, 학기) → 강의실 (한 교수는 한 학기에 한 강의실만 배정받는다고 가정)

여기서 (교수ID, 학기)는 결정자이지만 후보 키가 아니므로 BCNF 위반입니다.

### BCNF로 분해:

**교수학기 테이블**
| 교수ID | 학기 | 강의실 |
|--------|------|--------|
| P01 | 2023-1 | 공학관 110호 |
| P02 | 2023-1 | 공학관 120호 |
| P03 | 2023-1 | 과학관 220호 |
| P04 | 2023-2 | 공학관 110호 |

**과목개설 테이블**
| 과목코드 | 교수ID | 학기 |
|----------|--------|------|
| CS101 | P01 | 2023-1 |
| CS102 | P02 | 2023-1 |
| MATH101 | P03 | 2023-1 |
| CS101 | P04 | 2023-2 |

BCNF의 핵심은 "무언가를 결정할 수 있는 힘을 가진 속성이라면, 그 속성은 반드시 테이블의 식별자(후보 키)여야 한다"는 것입니다. 이렇게 하면 데이터 중복과 갱신 이상을 더 철저히 방지할 수 있습니다.

## 제4정규형(4NF)

제4정규형을 달성하는 단계

### 1단계: 모든 속성이 기본 키에 종속되고 서로 독립적인지 확인하기

이 단계는 모든 속성이 테이블의 기본 키에 직접 종속되어야 하며, 다른 속성들과 독립적이어야 함을 의미합니다. 즉, 속성들 간에 서로 영향을 주고받는 관계가 없어야 합니다.

### 2단계: 테이블이 개체에 대한 두 개 이상의 다치 사실을 포함하는 행이 없는지 확인하기

여기서 '다치 사실(multi-valued facts)'이란 하나의 개체에 대해 여러 값을 가질 수 있는 특성을 말합니다. 4NF는 이러한 다치 관계가 서로 독립적일 때 각각 별도의 테이블로 분리되어야 한다고 요구합니다.

### 예시

학생 테이블에서 한 학생이 여러 과목을 수강하고, 여러 동아리에 가입할 수 있다고 가정해봅시다:

**4NF 위반 테이블**:
| 학번 | 수강과목 | 가입동아리 |
|------|----------|------------|
| 1001 | 수학 | 축구부 |
| 1001 | 영어 | 독서부 |
| 1001 | 과학 | 축구부 |

이 테이블은 4NF를 위반합니다. 왜냐하면:

- 학생(1001)이 수강하는 과목(수학, 영어, 과학)과
- 학생(1001)이 가입한 동아리(축구부, 독서부)는
  서로 독립적인 다치 관계입니다.

**4NF로 분해한 테이블**:

학생\_수강과목:
| 학번 | 수강과목 |
|------|----------|
| 1001 | 수학 |
| 1001 | 영어 |
| 1001 | 과학 |

학생\_동아리:
| 학번 | 가입동아리 |
|------|------------|
| 1001 | 축구부 |
| 1001 | 독서부 |

이렇게 분리하면 4NF를 만족하게 됩니다. 각 테이블은 하나의 다치 관계만 표현하므로 더 이상 불필요한 데이터 중복이 발생하지 않습니다.

4NF는 복잡한 다치 관계가 있는 데이터베이스에서 특히 중요하며, 이를 통해 데이터 중복과 갱신 이상을 더욱 철저히 방지할 수 있습니다.

<br>

<br>

# 2. 관계형 데이터베이스를 사용하는 이유를 설명해주세요.

## 중요 키워드

- ACID 트랜잭션
- 데이터 무결성
- SQL (구조화 쿼리 언어)
- 관계 모델링 (1:1, 1:N, M:N)
- 스키마와 제약조건

## Script

관계형 데이터베이스(RDBMS)는 데이터를 테이블 형태로 구조화하고 테이블 간의 관계를 정의하여 데이터를 관리하는 시스템입니다. 이를 사용하는 주요 이유는 다음과 같습니다:

1. **데이터 무결성 보장**: 스키마, 제약조건, 트랜잭션을 통해 데이터의 정확성과 일관성을 유지할 수 있습니다. 예를 들어, 외래 키 제약조건으로 참조 무결성을 보장합니다.
2. **ACID 트랜잭션**: 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability) 특성을 보장하여 안전한 데이터 처리가 가능합니다.
3. **구조화된 쿼리 언어(SQL)**: 표준화된 SQL을 통해 복잡한 데이터 조작과 조회가 가능하며, 선언적 언어로 '무엇을' 원하는지 명시하면 DBMS가 '어떻게' 가져올지 최적화합니다.
4. **관계 모델링의 유연성**: 테이블 간 관계(1:1, 1:N, M:N)를 정의하여 복잡한 비즈니스 로직을 효과적으로 표현할 수 있습니다.
5. **성숙한 생태계**: 오랜 기간 발전해온 기술로, 안정성, 보안, 백업, 복구 메커니즘이 잘 갖춰져 있습니다.

다만, 모든 상황에 관계형 데이터베이스가 최선은 아닙니다. 대용량 비구조화 데이터나 스키마가 자주 변경되는 경우, NoSQL 데이터베이스가 더 적합할 수 있으며, 실시간 분석이나 그래프 데이터는 특수 목적 데이터베이스가 더 효율적일 수 있습니다. 저는 프로젝트 요구사항에 따라 적절한 데이터베이스를 선택하는 것이 중요하다고 생각합니다.

**주요 이유**:

1. **데이터 무결성**:

- 스키마 정의로 데이터 형식 보장
- 제약조건으로 유효한 데이터만 저장
- 외래 키로 참조 무결성 유지

2. **ACID 트랜잭션**:

- 원자성: 모든 작업 성공 또는 실패
- 일관성: 트랜잭션 전후 규칙 유지
- 격리성: 동시 트랜잭션 간섭 방지
- 지속성: 완료된 트랜잭션 결과 영구 저장

3. **구조화된 쿼리 언어(SQL)**:

- 표준화된 언어로 다양한 DBMS 사용 가능
- 선언적 언어로 최적화는 DBMS가 처리

4. **관계 모델링**:

- 복잡한 비즈니스 관계 표현 가능
- 데이터 간 관계 명확히 정의

5. **안정성과 성숙도**:

- 수십 년간 검증된 기술과 도구
- 강력한 백업/복구 메커니즘

### RDBMS vs NoSQL 선택 기준

| 상황                                         | 적합한 선택 |
| -------------------------------------------- | ----------- |
| 복잡한 트랜잭션이 필요한 경우                | RDBMS       |
| 데이터 구조가 명확하고 일관적인 경우         | RDBMS       |
| 대용량 데이터의 빠른 읽기/쓰기가 필요한 경우 | NoSQL       |
| 스키마가 자주 변경되는 경우                  | NoSQL       |
| 수평적 확장성이 중요한 경우                  | NoSQL       |

## 더 알아야할 내용

### Q. NoSQL과 비교했을 때 RDBMS의 단점은 무엇인가요?

수평 확장성(Scalability) 제한, 스키마 변경 어려움, 비정형 데이터 처리의 불편함이 있습니다. 대용량 트래픽에서는 확장 비용이 높을 수 있습니다.

### Q. 어떤 경우에 NoSQL을 선택해야 할까요?

대용량 데이터, 빠른 읽기/쓰기가 필요한 경우, 스키마가 자주 변경되는 경우, 수평적 확장이 중요한 경우에 적합합니다.

### Q. 하이브리드 접근법은 어떻게 활용하나요?

주요 트랜잭션 데이터는 RDBMS에, 로그/세션 등은 NoSQL에 저장하는 방식입니다. 마이크로서비스 아키텍처에서 서비스별로 적합한 DB 선택이 가능합니다.

<br>

<br>

# 3. RESTful API의 개념과 주요 제약 조건을 설명하세요.

## 중요 키워드

- 자원(Resource)과 표현(Representation)
- HTTP 메서드(GET, POST, PUT, DELETE)
- 무상태(Stateless)
- 균일한 인터페이스(Uniform Interface)
- HATEOAS
- 리소스 식별(URI)

## Script

RESTful API는 REST(Representational State Transfer) 아키텍처 스타일을 따르는 API로, 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하여 웹 서비스를 설계하는 방법론입니다.

1. **클라이언트-서버 구조(Client-Server)**: 사용자 인터페이스와 데이터 저장을 분리하여 각각 독립적으로 발전할 수 있게 합니다.
2. **무상태(Stateless)**: 서버는 클라이언트의 상태 정보를 저장하지 않고, 각 요청을 독립적으로 처리해야 합니다. 이는 서버 설계의 단순성과 확장성을 증가시킵니다.
3. **캐시 가능(Cacheable)**: 응답은 캐시 가능 여부를 명시해야 하며, 효율적인 캐싱을 통해 성능을 최적화할 수 있습니다.
4. **계층화 시스템(Layered System)**: 클라이언트는 서버와 직접 연결되었는지, 중간 서버를 통해 연결되었는지 알 수 없습니다. 이를 통해 로드 밸런싱, 공유 캐시 등의 미들웨어를 추가할 수 있습니다.
5. **인터페이스 일관성(Uniform Interface)**: 이는 REST의 핵심 제약조건으로, 다음 네 가지 원칙을 포함합니다:

- 자원 식별(URI를 통한 리소스 식별)
- 표현을 통한 자원 조작(HTTP 메서드 활용)
- 자기 서술적 메시지(미디어 타입 등 메타데이터 활용)
- HATEOAS(애플리케이션 상태는 하이퍼링크를 통해 전이)

6. **코드 온 디맨드(선택사항)**: 서버에서 클라이언트로 실행 가능한 코드를 전송하여 클라이언트 기능을 확장할 수 있습니다.

실무에서 RESTful API를 설계할 때는 다음과 같은 방식을 적용합니다:

- URI에는 명사를 사용하여 리소스를 표현합니다 (예: /users, /products)
- HTTP 메서드(GET, POST, PUT, DELETE)를 사용하여 CRUD 작업을 표현합니다
- 적절한 HTTP 상태 코드를 반환합니다(200 OK, 201 Created, 400 Bad Request 등)
- 응답에 하이퍼링크를 포함하여 관련 리소스를 탐색할 수 있게 합니다

예를 들어, 제가 개발한 웹 서비스에서는 사용자 관리 API를 `/users`(GET: 목록 조회, POST: 생성), `/users/{id}`(GET: 상세 조회, PUT: 수정, DELETE: 삭제)와 같이 설계했고, JSON 형식으로 데이터를 주고받으며 적절한 상태 코드와 에러 메시지를 반환했습니다. 이를 통해 클라이언트 개발자가 직관적으로 API를 이해하고 사용할 수 있었습니다."

### 정리

**정의**: REST는 웹의 기존 기술과 HTTP 프로토콜을 활용하는 아키텍처 스타일로, 자원을 중심으로 상태 전달에 초점

**주요 제약조건**:

1. **클라이언트-서버 구조**:

- 관심사 분리로 각각 독립적 진화 가능
- 인터페이스 일관성 유지하며 구현 변경 가능

2. **무상태(Stateless)**:

- 요청은 모든 필요 정보 포함
- 세션 상태 서버에 저장 안 함
- 서버 확장성 향상, 구현 단순화

3. **캐시 가능(Cacheable)**:

- 응답은 캐시 여부 명시
- 네트워크 효율성 향상

4. **계층화 시스템**:

- 클라이언트는 중간 계층 인지 못함
- 로드 밸런싱, 공유 캐시, 보안 계층 추가 가능

5. **균일한 인터페이스**:

- 리소스 식별(URI)
- 표현을 통한 리소스 조작(HTTP 메서드)
- 자기 서술적 메시지
- HATEOAS(하이퍼링크로 상태 전이)

**실무 적용 원칙**:

- 리소스는 명사 사용(URI)
- HTTP 메서드로 CRUD 표현
- 적절한 상태 코드 사용
- 일관된 응답 형식
- 버전 관리 적용

#### RESTful API 설계 예시

**사용자 관리 API:**

| 작업             | HTTP 메서드 | URL             | 설명                      |
| ---------------- | ----------- | --------------- | ------------------------- |
| 사용자 목록 조회 | GET         | /api/users      | 페이지네이션, 필터링 지원 |
| 특정 사용자 조회 | GET         | /api/users/{id} | 단일 사용자 정보 반환     |
| 사용자 생성      | POST        | /api/users      | 새 사용자 정보 생성       |
| 사용자 수정      | PUT/PATCH   | /api/users/{id} | 사용자 정보 갱신          |
| 사용자 삭제      | DELETE      | /api/users/{id} | 사용자 정보 삭제          |

## 더 알아야할 내용

### Q. REST와 GraphQL의 차이점은 무엇인가요?

REST는 리소스 중심이고 여러 엔드포인트가 있지만, GraphQL은 단일 엔드포인트로 필요한 데이터만 정확히 요청할 수 있습니다. REST는 버전 관리가 필요하나 GraphQL은 스키마 진화가 유연합니다.

### Q. 완벽한 REST API를 구현하기 어려운 이유는?

HATEOAS 구현이 복잡하고, 클라이언트가 이를 제대로 활용하지 않는 경우가 많습니다. 또한 프론트엔드 요구사항에 맞춰 리소스 설계가 왜곡될 수 있습니다.

### Q. REST API 버전 관리 전략은?

URI 경로(/v1/users), 쿼리 파라미터(?version=1), 헤더(Accept: application/vnd.api+json;version=1.0), 도메인(api-v1.example.com) 등의 방법이 있습니다. 프로젝트 특성에 맞게 선택합니다.

### HATEOAS (Hypermedia as the Engine of Application State)

> HATEOAS는 "Hypermedia as the Engine of Application State"의 약자로, REST 아키텍처의 핵심 제약 조건 중 하나입니다.

#### 기본 개념

HATEOAS의 핵심 아이디어는 **클라이언트가 서버로부터 받은 하이퍼링크를 통해 애플리케이션의 상태를 전이(navigate)한다**는 것입니다. 쉽게 말해:

1. API 응답이 단순 데이터뿐만 아니라 **관련 작업에 대한 링크도 함께 제공**
2. 클라이언트는 **미리 하드코딩된 URL을 알 필요 없이** 서버가 제공한 링크만으로 다음 동작 수행 가능
3. 마치 웹사이트에서 하이퍼링크를 클릭하며 탐색하는 것과 유사한 방식

#### 예시

**일반적인 RESTful API 응답:**

```json
{
  "id": 123,
  "name": "스마트폰",
  "price": 500000
}
```

**HATEOAS가 적용된 응답:**

```json
{
  "id": 123,
  "name": "스마트폰",
  "price": 500000,
  "_links": {
    "self": { "href": "/products/123" },
    "reviews": { "href": "/products/123/reviews" },
    "related": { "href": "/products/123/related" },
    "add-to-cart": {
      "href": "/cart/items",
      "method": "POST"
    }
  }
}
```

#### HATEOAS의 장점

1. **클라이언트-서버 결합도 감소**: 클라이언트가 URL 구조를 하드코딩할 필요가 없음
2. **API 변경에 유연**: 서버 측 URL이 변경되어도 클라이언트 수정 불필요
3. **API 탐색 용이**: 클라이언트가 가능한 다음 작업을 쉽게 발견
4. **자기 문서화**: API가 스스로 사용 방법을 안내

#### 실무 활용

실제로는 완벽한 HATEOAS를 구현하는 경우가 드물고, 부분적으로 적용하는 경우가 많습니다. HAL(Hypertext Application Language), JSON:API 등의 표준 형식을 활용해 구현할 수 있습니다.

REST의 진정한 의미에서는 HATEOAS가 필수지만, 많은 "RESTful API"라 불리는 서비스들이 이 제약조건을 완전히 만족시키지는 않습니다.
