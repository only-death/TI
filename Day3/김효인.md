## 쿠키

- **쿠키**
  - 클라이언트에서 사용자의 정보를 저장했다가 필요할 때 참조하거나 재사용할 수 있는 key-value 쌍으로 구성된 데이터 파일
  - 서버가 사용자의 로그인 정보를 유지하기 위해 세션 ID를 쿠키에 저장하여 클라이언트가 요청할 때마다 전송함
  - 하나의 쿠키는 최대 4KB까지 저장이 가능함
  - 쿠키의 기한이 정해져 있지 않고 명시적으로 지우지 않으면 반 영구적으로 쿠키가 남아있음
- **로그인 FLOW**

  - ① 사용자 로그인 → ② 서버에서 세션 생성 & 쿠키에 세션 ID 저장 → ③ 이후 요청마다 쿠키 전송

- **주로 사용 목적**
  - **로그인, 사용자 닉네임, 접속시간, 장바구니 등** 서버가 알아야 할 정보 저장
  - **개인화**: 사람마다 다르게 적절한 페이지 보여 주기
  - **트래킹**: 사용자의 행동과 패텅을 분석하고 기록
- **단점**
  - 클라이언트에서 쿠키 수정 및 **위변조의 위험** 존재
  - **보안 문제**
    - 쿠키는 클라이언트 측에서 저장되므로 **XSS(Cross-Site Scripting) 공격**에 의해 탈취될 가능성이 있음
    - **CSRF(Cross-Site Request Forgery) 공격**에도 취약할 수 있음
    - `HttpOnly`와 `Secure` 속성을 설정하면 보안 강화 가능하지만 완전한 해결책은 아님
  - **트래픽 증가**
    - 쿠키는 **모든 HTTP 요청에 포함되어 전송**되기 때문에 쿠키 크기가 커지면 트래픽 부담이 증가함
    - 대용량 데이터를 저장하기 어렵고 보통 `localStorage`나 `sessionStorage` 같은 다른 클라이언트 저장소와 함께 사용됨

---

## 세션

- **세션**
  - 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장
    - 유입된 사람이 많을수록 데이터에 과부화가 일어날 수 있음
  - 각 클라이언트에 고유 세션 ID를 부여해 각 요구에 맞는 서비스 제공
  - 브라우저가 종료되기 전까지 클라이언트의 요청을 유지하게 해주는 기술
  - 저장 데이터에 제한이 없음
- **로그인 FLOW**
  - ① 사용자 로그인 → ② 서버에서 세션 저장 & 세션 ID 반환 → ③ 이후 요청에서 세션 ID 사용
- **주로 사용 목적**
  - 내부 시스템
  - 웹 애플리케이션
- 단점
  - **서버 부하 문제**
    - 모든 클라이언트의 세션을 서버에서 관리하므로, 접속자가 많아지면 **메모리 사용량이 증가**하여 서버 과부하가 발생할 수 있음
  - **확장성 문제 (Scalability)**
    - 서버를 여러 대 운영하는 경우(로드 밸런싱), 사용자가 로그인한 서버와 요청하는 서버가 다르면 **세션 정보가 동기화되지 않아 인증이 깨질 수 있음**
    - 이를 해결하려면 **세션 클러스터링**(모든 서버가 같은 세션 저장소 사용, 예: Redis, Memcached)을 해야 하지만 관리가 번거로움
  - **웹/앱 인증 방식 차이**
    - 기존에는 **웹 브라우저 기반 클라이언트**만 존재했지만, 이제는 모바일 앱, IoT 등 다양한 클라이언트가 생김
    - 앱과 웹의 쿠키/세션 방식이 다를 수 있어 API 서버를 별도로 설계해야 하는 경우가 많음(앱은 HTTP 요청을 직접 만들어야 하는 등의 이유로 다른 경우가 많음)

---

### JWT 기반

- **JWT**

  - 토큰 기반 인증 방식으로 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 간결하고 독립적인 방법을 정의하는 공개 표준([RFC 7519](https://tools.ietf.org/html/rfc7519))
  - 웹/ 앱 등에서 기기가 바뀔 경우 동일한 인증 방식 처리 가능

  - **자체적으로 인증 정보 포함**
    - JWT 자체가 사용자의 정보를 포함하고 있어서, **서버에서 별도 DB 조회 없이도 검증 가능**
    - **사용자가 탈퇴하거나 권한이 변경되었을 때 기존 JWT는 계속 유효할 수 있음** → 그래서 **Refresh Token 전략이 필요함**
  - **무상태(Stateless) 인증**
    - 서버가 별도로 세션을 저장하지 않아도 인증 가능
    - 서버가 확장(Scale-out)될 때 유리함

- **로그인 FLOW**
  - ① 사용자 로그인 → ② 서버에서 JWT 발급 → ③ 이후 요청마다 JWT를 헤더에 포함하여 전송
- **주로 사용 목적**
  - 웹/앱 API 인증
  - 마이크로서비스
- **단점**
  - **JWT 탈취 시 위험**
    - JWT는 클라이언트에서 저장되기 때문에, **탈취되면 그대로 재사용 가능** → 그래서 보통 **Access Token 만료 + Refresh Token 재발급 방식**을 사용함
    - 토큰 저장 위치에 따라 보안이 다름:
      - `localStorage` → XSS에 취약
      - `httpOnly cookie` → CSRF 공격 가능성
  - **트래픽 증가**
    - JWT는 **모든 HTTP 요청의 Authorization 헤더에 포함되어 전송**되므로, 토큰의 길이가 길어질수록 트래픽 부담이 증가할 수 있음
    - 일부 서버는 **HTTP 헤더 크기 제한(보통 8KB 이하)이 있어**, 너무 큰 JWT는 처리되지 않을 수 있음
    - 이를 해결하려면 **JWT 크기를 최적화하거나, [Auth0 세분화된 권한 부여](https://fga.dev/) 같은 대체 솔루션을 고려할 수 있음**
  - **즉시 만료가 어려움**
    - 세션 기반 인증은 서버에서 강제로 만료할 수 있지만, JWT는 **이미 발급된 토큰을 서버에서 무효화하기 어려움**
    - **해결 방법**:
      - Access Token의 유효 기간을 짧게 설정하고, Refresh Token을 사용하여 재발급

---

### OAuth

- **OAuth**
  - 소셜 로그인처럼 **OAuth 2.0 기반 인증** 선호
  - 외부 인증 서버가 인증을 처리해 주므로 세션 관리를 할 필요가 없음
  - 세션 관리 불필요/ 웹,앱 간의 동일한 인증 방식 적용 가능, 비밀번호 저장 불필요, 소셜 로그인 및 API 연동 용이
- **로그인 FLOW**
  - ① 사용자 로그인 → ② 인증 서버에서 액세스 토큰 발급 → ③ 액세스 토큰을 사용하여 API 요청
- **주로 사용 목적**
  - 소셜 로그인
  - 3rd-party API 사용
- **단점**
  - **OAuth 제공자에 의존적**
    - 만약 서비스가 중단된다면 영향이 있음
  - **Access Token 제한적인 유효기간**
    - Refresh Token을 사용하여 재발급 관리
  - **OAuth Flow 복잡성**

### 추천하고 싶은 인증 방법: JWT

1. **확장성**
   - **무상태(stateless) 인증** 방식이라 **서버가 세션을 관리할 필요 없음** → API 서버 확장 시 유리함
     - 서버 간 공유할 필요 없이 클라이언트가 토큰을 보유하고 인증을 수행
     - 서버는 저장할 필요 없이 **검증**만 하면 됨
2. **웹/앱 동일한 인증 방식**
   - JWT는 HTTP 요청 헤더에 포함시켜 웹, 모바일 앱, 마이크로서비스 등 다양한 환경에서 동일한 방식으로 사용 가능
   - 모바일 앱은 보통 쿠키 대신 JWT를 저장하고 HTTP 헤더로 전송
3. **IaaS(클라우드) 환경에 적합**
   - AWS, GCP, Azure 같은 IaaS 클라우드 서비스에서 마이크로서비스 아키텍처(MSA)를 구축할 때 JWT가 선호됨
   - API Gateway에서 JWT를 검증하면 개별 서비스가 별도 인증을 수행할 필요가 없음 → 부하 감소
     - API Gateway: 어떤 규모에서든 개발자가 API를 손쉽게 생성, 게시, 유지 관리, 모니터링 및 보안 유지할 수 있도록 하는 완전관리형 서비스
4. **보안성 강화 가능**
   - JWT는 `httpOnly cookie` 또는 `Secure Storage`에 저장하여 보안 강화 가능
   - `Access Token`은 짧게 유지, `Refresh Token`으로 자동 연장하며 보안과 편의성을 함께 고려 가능
