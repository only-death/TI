# 브라우저가 어떻게 동작하는지 설명해 주세요.

## 중요 키워드

- 렌더링 엔진 (Rendering Engine)
  - Chrome, Edge, Opera: Blink 엔진
  - Firefox: Gecko 엔진
  - Safari: WebKit 엔진
- 파싱 (Parsing) : HTML, CSS 등의 코드를 읽어 브라우저가 이해할 수 있는 데이터 구조로 변환하는 과정
- DOM (Document Object Model) :웹 페이지의 객체 기반 표현입니다. HTML 요소들을 노드로 표현한 트리 구조
- CSSOM (CSS Object Model): CSS 스타일시트의 객체 표현으로, 상속과 캐스케이딩 규칙이 이 단계에서 적용.
- 렌더 트리 (Render Tree): DOM과 CSSOM을 결합하여 만든 트리로, 화면에 실제로 표시될 요소들만 포함 (display: none 같이 시각적으로 안보이는것은 제외)
- 레이아웃 (Layout) / 리플로우 (Reflow) :렌더 트리의 각 노드가 화면의 정확한 위치와 크기를 계산하는 과정 / 요소의 크기나 위치가 변경되면 리플로우가 발생
- 페인팅 (Painting): 레이아웃 단계에서 계산된 정보를 바탕으로 실제 화면에 픽셀을 그리는 과정
- 자바스크립트 엔진: JavaScript 코드를 실행하는 브라우저 구성 요소

## Script

브라우저는 사용자가 요청한 웹 페이지를 화면에 표시하기 위해 여러 단계의 과정을 거칩니다.
먼저, 네트워크 요청 단계에서는 사용자가 URL을 입력하면 브라우저가 DNS 서버에 해당 도메인의 IP 주소를 요청합니다. IP 주소를 얻으면 해당 서버에 HTTP 요청을 보내고, 서버는 HTML 문서를 응답으로 반환합니다.
다음으로, 파싱 단계에서는 브라우저의 렌더링 엔진이 HTML 문서를 분석해 DOM 트리를 구축합니다. DOM은 웹 페이지의 구조를 나타내는 객체 모델입니다. 이 과정에서 CSS 파일 링크를 만나면, 해당 CSS를 요청하고 파싱하여 CSSOM을 생성합니다.
세 번째로, 렌더 트리 구축 단계에서는 DOM과 CSSOM을 결합하여 화면에 표시될 요소들만 포함하는 렌더 트리를 만듭니다. 예를 들어, display: none이 적용된 요소는 렌더 트리에 포함되지 않습니다.
네 번째로, 레이아웃(또는 리플로우) 단계에서는 각 요소의 정확한 위치와 크기를 계산합니다. 이때 %, em과 같은 상대적인 값들이 픽셀 단위의 절대값으로 변환됩니다.
마지막으로, 페인팅 단계에서는 계산된 레이아웃을 기반으로 실제 화면에 픽셀을 그립니다. 텍스트, 색상, 이미지 등 모든 시각적 요소가 이 단계에서 처리됩니다.
한편, 자바스크립트는 이 전체 과정에 큰 영향을 미칩니다. HTML 파싱 중 `<script>` 태그를 만나면 파싱이 일시 중단되고 자바스크립트가 실행됩니다. 이 스크립트는 DOM을 변경할 수 있어 렌더링 과정에 영향을 줍니다. 이런 이유로 스크립트는 보통 `<body>` 태그 끝에 배치하거나, async나 defer 속성을 사용해 HTML 파싱을 차단하지 않도록 합니다.
최근 브라우저들은 성능 향상을 위해 점진적 렌더링이나 컴포지팅 같은 기술을 사용합니다. 점진적 렌더링은 전체 HTML을 파싱하기 전에 일부 콘텐츠를 먼저 보여주는 것이고, 컴포지팅은 여러 레이어로 나누어 처리하는 기술입니다.
이러한 브라우저 렌더링 과정을 이해하면 웹 성능 최적화에 큰 도움이 됩니다. 예를 들어, 불필요한 리플로우와 리페인트를 줄이거나, 중요한 CSS를 인라인으로 포함시키는 등의 최적화 기법을 적용할 수 있습니다.

**실무 예시**
실제 개발 시 이 원리를 활용한 최적화 방법으로는, CSS는 `<head>` 태그 내에 배치하여 렌더 차단을 방지하고, JavaScript는 가능한 `<body>` 태그 끝에 배치하거나 async/defer 속성을 사용하여 HTML 파싱을 차단하지 않도록 합니다.
또한 애니메이션이나 레이아웃 변경이 많은 웹 애플리케이션에서는 transform이나 opacity 같은 속성을 사용하여 리플로우 대신 GPU 가속을 활용한 컴포지팅만 발생시키는 것이 성능에 유리합니다. 이런 최적화 기법들은 모두 브라우저의 렌더링 과정을 이해하고 있을 때 효과적으로 적용할 수 있습니다.

## 더 알아야할 내용

### Q: 크리티컬 렌더링 패스(Critical Rendering Path)란 무엇인가요?

크리티컬 렌더링 패스는 브라우저가 HTML, CSS, JavaScript를 처리하여 화면에 픽셀을 그리는 일련의 단계를 말합니다. 이는 DOM 및 CSSOM 구축, 렌더 트리 생성, 레이아웃 계산, 페인팅 과정을 포함합니다. 웹 성능 최적화에서 중요한 개념으로, 이 경로를 최적화하면 초기 로딩 시간과 사용자 경험을 크게 개선할 수 있습니다. 예를 들어, 중요한 CSS를 인라인으로 포함시키거나, 불필요한 JavaScript를 지연 로딩하는 등의 방법으로 크리티컬 렌더링 패스를 최적화할 수 있습니다.

### Q: 리플로우(Reflow)와 리페인트(Repaint)의 차이점은 무엇인가요?

리플로우는 요소의 크기나 위치가 변경되어 레이아웃을 다시 계산하는 과정입니다. 예를 들어, 요소의 `width`, `height`, `margin` 등을 변경하면 리플로우가 발생합니다. 이는 계산 비용이 높은 작업입니다.
리페인트는 요소의 시각적 속성만 변경되어 레이아웃 재계산 없이 화면을 다시 그리는 과정입니다. 예를 들어, `color`, `background-color`, `visibility` 등을 변경하면 리페인트만 발생합니다.
리플로우는 항상 리페인트를 동반하지만, 리페인트는 리플로우 없이도 발생할 수 있습니다. 성능 최적화 관점에서는 가능한 리플로우를 줄이고, 필요한 경우 리페인트만 발생시키는 것이 좋습니다. 예를 들어, 애니메이션에 transform 속성을 사용하면 리플로우 없이 GPU 가속을 통한 컴포지팅만 발생시켜 성능을 향상시킬 수 있습니다.

### Q: 브라우저의 렌더링 과정에서 자바스크립트가 미치는 영향은 무엇인가요?

자바스크립트는 브라우저 렌더링 과정에 여러 방식으로 영향을 미칩니다. 첫째, HTML 파싱 중 `<script>` 태그를 만나면 파싱이 일시 중단되고 스크립트가 실행됩니다. 이는 DOM 구축을 지연시킬 수 있습니다. 둘째, 자바스크립트는 DOM과 CSSOM을 조작할 수 있어, 실행 결과에 따라 렌더 트리가 변경될 수 있습니다. 셋째, 자바스크립트로 요소의 스타일이나 위치를 변경하면 리플로우와 리페인트가 발생할 수 있습니다.
이러한 영향을 최소화하기 위해 `async`나 `defer` 속성을 사용하여 스크립트 로딩을 최적화하거나, DOM 조작을 최소화하고 일괄 처리하는 방법, `requestAnimationFrame`을 사용한 애니메이션 최적화 등의 기법을 사용할 수 있습니다. 또한 `Web Workers`를 활용하면 메인 스레드를 차단하지 않고 복잡한 계산을 수행할 수 있습니다.

---

## 브라우저 렌더링 플로우 구조화

### 1. 네트워크 요청 단계

- URL 입력 → DNS 조회 → IP 주소 확인
- HTTP 요청 → 서버 연결 → HTML 문서 수신

### 2. 파싱 단계

- HTML 파싱 → DOM 트리 구축
- CSS 파싱 → CSSOM 트리 구축
- JavaScript 처리 → DOM/CSSOM 조작 가능

### 3. 렌더 트리 구축

- DOM + CSSOM 결합 → 렌더 트리 생성
- 화면에 표시될 요소만 포함 (display: none 제외)
- 시각적 속성 결정 (색상, 크기 등)

### 4. 레이아웃 (리플로우) 단계

- 요소 위치와 크기 계산 → 뷰포트 내 정확한 좌표 결정
- 상대값 → 절대 픽셀값 변환
- 박스 모델 적용 (margin, padding, border 등)

### 5. 페인팅 단계

- 픽셀 단위 그리기 → 텍스트, 색상, 이미지, 그림자 등
- 레이어 생성 → 필요시 별도 레이어로 처리
- 컴포지팅 → 여러 레이어 합성하여 최종 화면 구성

### 최적화 포인트

- CSS 배치: `<head>` 내에 배치 (빠른 CSSOM 구축)
- JavaScript 배치: `<body>` 끝에 배치 또는 async/defer 속성 사용
- 리플로우 최소화: 레이아웃 변경 일괄 처리
- GPU 가속 활용: transform, opacity 사용 (컴포지팅만 발생)
- 중요 리소스 우선 로딩: 크리티컬 CSS 인라인 포함
- 성능 이슈 키워드
- 렌더 차단 리소스: CSS, 동기 JavaScript
- 파서 차단 리소스: 동기 JavaScript
- 리플로우 vs 리페인트: 레이아웃 재계산 vs 시각적 속성만 변경
- 크리티컬 렌더링 패스: 초기 화면 표시까지의 필수 단계들
- 점진적 렌더링: 전체 페이지 로드 전 일부 콘텐츠 먼저 표시
- 고급 최적화 기법
- 레이지 로딩: 필요할 때 리소스 로드
- 코드 스플리팅: 필요한 코드만 로드
- Web Workers: 메인 스레드 차단 없이 복잡한 계산 수행
- requestAnimationFrame: 애니메이션 최적화
- 가상 DOM: 실제 DOM 조작 최소화 (React, Vue 등)

---

## 질문 의도

### 1. 렌더링 프로세스 이해

- 크리티컬 렌더링 패스: 초기 화면 표시까지의 필수 단계 이해
- 렌더 차단 리소스: CSS와 JavaScript가 렌더링에 미치는 영향
- 점진적 렌더링: 사용자 경험 향상을 위한 렌더링 최적화 기법

### 2. 성능 최적화 지식

- 리플로우와 리페인트 차이점: 성능에 미치는 영향 이해
- JavaScript 최적화: async/defer 속성의 목적과 차이점
- GPU 가속: transform, opacity 등을 활용한 렌더링 최적화

### 3. 실무 적용 능력

- CSS 배치 전략: CSS를 head에 배치하는 이유
- JavaScript 배치 전략: body 끝에 배치하거나 async/defer 사용 이유
- 애니메이션 최적화: requestAnimationFrame 활용 방법

### 4. 최신 웹 개발 트렌드 인식

- 컴포지팅: 최신 브라우저의 레이어 처리 방식
- 가상 DOM: React, Vue 등 프레임워크의 렌더링 최적화 방식
- Web Workers: 메인 스레드 차단 없는 작업 처리 방법

### 5. 디버깅 및 문제 해결 능력

- 렌더링 병목 현상 식별: 성능 저하 원인 파악 능력
- 개발자 도구 활용: 렌더링 성능 측정 및 분석 방법
- 최적화 전략 수립: 상황에 맞는 최적화 기법 선택 능력
