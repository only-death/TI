## ☑ 리액트의 Reconciliation 과정에서 재귀가 끝나는 조건을 설명해주세요.

> **Reconciliation(재조정)** 은 React가 Virtual DOM을 기반으로, 이전 렌더 결과와 새 렌더 결과를 비교(diff)해서 실제 DOM을 효율적으로 업데이트하는 과정입니다.
>
> 쉽게 말해,  
> **"어떤 부분이 바뀌었는지 확인하고 → 필요한 부분만 다시 렌더링"**

### Reconciliation에서 재귀가 일어나는 이유

React는 Virtual DOM을 트리 구조로 저장하고 있기 때문에,  
변경된 내용을 파악하려면 트리 구조를 위에서 아래로, 노드마다 비교하는 작업이 필요합니다.  
→ 이 과정이 재귀적으로 수행됩니다.

### 재귀가 끝나는 조건

| 종료 조건                                         | 설명                                                             |
| ------------------------------------------------- | ---------------------------------------------------------------- |
| **노드가 자식이 없음**                            | 더 이상 내려갈 노드가 없을 때                                    |
| **type이 다름**                                   | React는 타입이 다르면 노드 전체를 교체함 (하위 비교 안 함)       |
| **key가 다름**                                    | key가 다르면 해당 리스트 아이템을 새로 렌더링함 (하위 비교 생략) |
| **shouldComponentUpdate / React.memo false 반환** | 명시적으로 자식 비교 생략 요청                                   |
| **같은 참조인 경우**                              | props나 children이 이전과 동일한 객체일 경우 비교 생략됨         |

### 🔍 예시로 보기

1. type이 다르면

```jsx
// 이전
<div>Hello</div>

// 이후
<span>Hello</span>
```

- `div` → `span`으로 변경됨 → React는 `<div>` 전체를 버리고 `<span>` 새로 만듦
- ✅ 자식인 `"Hello"`는 비교하지 않고 재귀 종료됨

2. key가 다르면

```jsx
<ul>
  <li key='a'>A</li>
  <li key='b'>B</li>
</ul>
```

```jsx
<ul>
  <li key='b'>B</li>
  <li key='a'>A</li>
</ul>
```

- key 순서가 바뀌었기 때문에 React는 **전체를 새로 렌더링**
- ✅ 자식 비교 생략, 재귀 중단됨

3. React.memo나 shouldComponentUpdate 사용 시

```jsx
const MemoComp = React.memo((props) => {
  console.log('렌더링됨');
  return <div>{props.value}</div>;
});
```

- 부모가 렌더링되더라도 `props.value`가 같으면 **재귀 호출 안 됨**
- ✅ 메모이제이션 조건에 따라 재귀 중단

### 💯 정리

React의 Reconciliation 과정은 변경된 Virtual DOM 트리를 기존 트리와 비교하며 재귀적으로 내려가며 변경 사항을 탐색합니다.
이 재귀는 노드가 더 이상 자식이 없거나, 변경 여부를 판단할 수 있는 조건에 도달했을 때 종료됩니다.
예를 들어, 노드의 `type`이 변경되었거나, `key`가 달라졌을 경우에는 해당 노드 이하 전체를 교체하므로 그 자식들에 대해 재귀적으로 비교하지 않고 종료됩니다.
즉, 재귀가 끝나는 조건은 **“더 내려가서 비교할 필요가 없다고 판단된 시점”** 입니다.
