# 기본 개념


## 1. JSX에 대해 설명해 주세요.

> JSX는 JavaScript에서 XML과 유사한 문법으로 UI를 작성하는 방식입니다.

> HTML과 비슷하지만 {}를 사용해 JavaScript 표현식을 포함할 수 있으며, Babel이 JSX를 React.createElement()로 변환하여 실행합니다. 이를 통해 가독성이 높아지고, 컴포넌트 기반 개발이 쉬워집니다.

> JSX는 브라우저에서 직접 실행되지 않으며, 반드시 변환 과정이 필요합니다.

## 2. React에서 배열을 렌더링할 때 key를 설정해야 하는 이유
> React에서 key는 리스트의 각 요소를 고유하게 식별하여 변경된 항목만 효율적으로 업데이트하기 위해 필요합니다.

> key가 없으면 React는 어떤 요소가 변경되었는지 정확히 알지 못해 불필요한 리렌더링이 발생할 수 있습니다. 또한, 리스트의 순서가 바뀔 때 기존 요소를 재사용하지 못하고 예상치 못한 UI 오류가 발생할 수도 있습니다.

> 따라서 id 같은 고유한 값을 key로 설정하는 것이 가장 좋으며, index를 key로 사용하면 예기치 않은 문제가 생길 수 있어 주의해야 합니다.

# 컴포넌트

## 3. state와 props의 차이를 설명해 주세요.
> state와 props는 컴포넌트에서 데이터를 관리하는 방법이지만 역할이 다릅니다.

> state는 컴포넌트 내부에서 관리되는 변경 가능한 값으로, useState를 사용해 업데이트할 수 있습니다. 반면, props는 부모 컴포넌트에서 자식 컴포넌트로 전달되는 읽기 전용 값으로, 직접 수정할 수 없습니다.

> 즉, state는 컴포넌트 내부에서 변경 가능하지만, props는 부모로부터 전달된 값이며 변경할 수 없습니다.


## 4. state를 직접 변경하지 않고 setState를 사용하는 이유를 설명해 주세요.
> React에서 state를 직접 변경하면 리렌더링이 발생하지 않아 UI에 반영되지 않을 수 있습니다.

> setState를 사용하면 React가 상태 변경을 감지하고 자동으로 리렌더링을 수행하여 UI를 최신 상태로 유지합니다. 또한, setState는 비동기적으로 동작하며, 여러 상태 업데이트를 배치(batch) 처리하여 성능을 최적화합니다.

> 따라서 state를 직접 수정하지 않고 반드시 setState를 사용해야 합니다.

# Hooks

## 5. React Hooks에 대해 설명해 주세요.
> React Hooks는 클래스형 컴포넌트 없이 함수형 컴포넌트에서도 상태 관리와 생명주기 기능을 사용할 수 있도록 해주는 기능입니다.

> 대표적으로 useState는 컴포넌트의 상태를 관리하고, useEffect는 컴포넌트의 생명주기와 유사한 동작을 수행합니다.

> 이 외에도 useContext, useReducer, useRef 등 다양한 Hook이 있으며, 커스텀 Hook을 만들어 코드의 재사용성을 높일 수도 있습니다.

> Hooks를 사용하면 코드가 간결해지고 유지보수가 쉬워지며, 클래스형 컴포넌트보다 가독성이 향상됩니다.

## 6. useState, useEffect에 대해 설명해 주세요.
> useState는 컴포넌트의 상태를 관리하는 Hook으로, 상태 값을 선언하고 setState 함수를 통해 업데이트할 수 있습니다.

> useEffect는 컴포넌트의 생명주기와 관련된 작업을 수행하는 Hook으로, 마운트, 업데이트, 언마운트 시 특정 로직을 실행할 수 있습니다. 의존성 배열을 활용하면 특정 값이 변경될 때만 실행되도록 제어할 수 있습니다.

> 함수형 컴포넌트에서 이 두 가지 Hook을 활용하면 클래스형 컴포넌트 없이도 상태 관리와 생명주기 관련 작업을 수행할 수 있습니다.

## 7. useEffect와 useLayoutEffect의 차이에 대해 설명해 주세요.
> useEffect는 렌더링이 완료된 후 비동기적으로 실행되며, 주로 데이터 요청이나 DOM 업데이트 같은 작업에 사용됩니다.

> 반면, useLayoutEffect는 렌더링 후 브라우저가 화면을 그리기 전에 동기적으로 실행되며, 레이아웃 측정이나 DOM 조작이 필요할 때 사용됩니다.

> 즉, useEffect는 비동기 실행되므로 UI가 깜빡일 수 있지만, useLayoutEffect는 동기 실행되어 레이아웃이 변경되기 전에 적용됩니다.

# 성능 최적화

## 8. React rendering 성능을 향상하기 위한 방법들을 설명해 주세요.
> React의 렌더링 성능을 향상시키기 위해 몇 가지 최적화 방법을 사용할 수 있습니다.

> 첫째, 불필요한 렌더링을 방지해야 합니다. React.memo를 사용하면 동일한 props로 불필요하게 렌더링되는 것을 막을 수 있습니다.

> 둘째, 컴포넌트 리렌더링 최소화가 필요합니다. useCallback과 useMemo를 활용하면 함수와 값을 메모이제이션하여 불필요한 렌더링을 줄일 수 있습니다.

> 셋째, 리스트 렌더링 최적화가 중요합니다. react-window 같은 라이브러리를 사용하면 가상화(Virtualization) 기법을 통해 렌더링 성능을 개선할 수 있습니다.

> 넷째, **코드 분할(Code Splitting)**을 활용하면 초기 로딩 속도를 개선할 수 있습니다. React.lazy와 Suspense를 사용하면 필요한 컴포넌트만 로드할 수 있습니다.

> 마지막으로, 상태 관리를 최적화해야 합니다. Recoil, Zustand 같은 경량 상태 관리 라이브러리를 사용하면 불필요한 렌더링을 줄일 수 있습니다.

## 9. 재조정(Reconciliation) 개념에 대해서 설명해 주세요.
> 재조정(Reconciliation)은 React가 변경된 부분만 찾아서 효율적으로 업데이트하는 과정을 의미합니다.

> React는 가상 DOM을 사용하여 이전 렌더링 결과와 새로운 렌더링 결과를 비교한 뒤, 변경된 부분만 실제 DOM에 반영합니다. 이를 위해 Diffing 알고리즘을 사용하며, key 값을 활용하여 최소한의 변경만 수행합니다.

> 이 과정 덕분에 전체 페이지를 다시 렌더링하지 않고도 빠르게 UI를 업데이트할 수 있습니다.

## 10. React Lifecycle에 대해 설명해 주세요.
> React Lifecycle은 컴포넌트가 생성되고, 업데이트되며, 제거되는 과정에서 특정 메서드가 실행되는 개념입니다.

> 클래스형 컴포넌트에서는 마운트, 업데이트, 언마운트 단계로 구분됩니다. 마운트 시 constructor, render, componentDidMount가 실행되며, 업데이트 시 shouldComponentUpdate로 렌더링을 최적화하고, componentDidUpdate에서 추가 작업을 수행할 수 있습니다. 컴포넌트가 제거될 때는 componentWillUnmount가 호출됩니다.

> 함수형 컴포넌트에서는 useEffect를 활용하여 같은 동작을 구현할 수 있습니다.

> 함수형 컴포넌트에서는 useEffect를 사용해 동일한 생명주기 기능을 구현할 수 있습니다.

# 상태 관리

## 11. Props drilling의 개념과 Props drilling을 피하는 방법에 대해 설명해 주세요.
> Props Drilling은 부모 컴포넌트에서 자식 컴포넌트를 거쳐 깊은 하위 컴포넌트까지 props를 계속 전달해야 하는 현상을 의미합니다. 컴포넌트 계층이 깊어질수록 코드가 복잡해지고 유지보수가 어려워질 수 있습니다.

> 이를 피하는 방법으로는 Context API를 사용하여 전역적으로 데이터를 공유하거나, Recoil, Zustand 같은 상태 관리 라이브러리를 활용하는 것이 있습니다. 또한, useReducer를 이용해 상태를 중앙에서 관리하면 불필요한 props 전달을 줄일 수 있습니다.

## 12. 전역 상태 관리 방법에 대해 설명해 주세요.
> 전역 상태 관리는 여러 컴포넌트에서 공통된 상태를 효율적으로 관리하는 방법입니다.

> 가장 기본적인 방법은 Context API를 사용하는 것이며, 전역 데이터를 props 없이 전달할 수 있습니다. 하지만 상태 변경이 잦으면 성능 문제가 발생할 수 있습니다.

> 더 확장된 방법으로 Redux, Recoil, Zustand 같은 상태 관리 라이브러리를 사용할 수 있습니다. Redux는 복잡한 상태 관리에 적합하고, Recoil과 Zustand는 더 간결하고 사용하기 쉽습니다.

> 상황에 따라 적절한 상태 관리 방법을 선택하는 것이 중요합니다


