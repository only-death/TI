#### 2025.03.11(Tue) Technical Interview 6

기본 개념

🇶 JSX에 대해 설명해 주세요.

🇶 React에서 배열을 렌더링할 때 key를 설정해야 하는 이유

컴포넌트

🇶 state와 props의 차이를 설명해 주세요.

🇶 state를 직접 변경하지 않고 setState를 사용하는 이유를 설명해 주세요.

Hooks

🇶 React Hooks에 대해 설명해 주세요.

🇶 useState, useEffect에 대해 설명해 주세요.

🇶 useEffect와 useLayoutEffect의 차이에 대해 설명해 주세요.

🇶 useMemo, useCallback 에 대해 설명하고, 어떤 경우에 사용하면 좋을지, 남용할 경우 발생할 수 있는 문제점을 설명해 주세요.

성능 최적화

🇶 React rendering 성능을 향상하기 위한 방법들을 설명해 주세요.

🇶 재조정(Reconciliation) 개념에 대해서 설명해 주세요.

🇶 React Lifecycle에 대해 설명해 주세요.

상태 관리

🇶 Props drilling의 개념과 Props drilling을 피하는 방법에 대해 설명해 주세요.

🇶 전역 상태 관리 방법에 대해 설명해 주세요.

배열 렌더링

🇶 React에서 배열을 렌더링할 때 key를 설정해야 하는 이유를 설명해 주세요.

전체 내용 => [블로그]() 참조

### JSX에 대해 설명해 주세요.

JSX는 JavaScript XML의 약자로, JavaScript 내에서 HTML처럼 구조를 작성할 수 있게 해주는 문법 확장입니다. JSX는 실제로 JavaScript로 변환되기 전 단계에서 HTML 태그와 유사한 구문을 사용하여 UI를 정의합니다. 이를 통해 코드의 가독성을 높이고, 선언적으로 UI를 정의할 수 있습니다.

### state와 props의 차이를 설명해 주세요.

state: 컴포넌트 내에서 관리되는 데이터로, 컴포넌트 자체에서 수정할 수 있습니다. 컴포넌트의 상태를 나타내며, 변경 시 컴포넌트를 다시 렌더링합니다.

props: 부모 컴포넌트에서 자식 컴포넌트로 전달되는 데이터입니다. 자식 컴포넌트는 props를 읽기만 할 수 있으며, 수정할 수 없습니다. 컴포넌트 간 데이터 흐름을 설정하는 데 사용됩니다.

### state를 직접 변경하지 않고 setState를 사용하는 이유를 설명해 주세요.

리액트에서 state는 직접 변경하지 않고, setState를 사용하여 변경해야 하는 이유는 리액트가 상태 변경을 추적하고, 상태 변경 후 컴포넌트의 리렌더링을 효율적으로 처리하기 위해서입니다. setState는 비동기적으로 동작하며, 상태 변경 후 리렌더링을 트리거합니다. 직접 상태를 변경하면 리렌더링이 일어나지 않거나 예상하지 못한 결과를 초래할 수 있습니다.

### React Hooks에 대해 설명해 주세요.

React Hooks는 함수형 컴포넌트에서 상태 관리와 라이프사이클 기능을 사용할 수 있게 해주는 함수입니다. useState, useEffect, useContext 등 여러 가지 Hook을 제공하며, 클래스형 컴포넌트에서만 가능했던 기능을 함수형 컴포넌트에서도 사용할 수 있게 해줍니다.

### useState, useEffect에 대해 설명해 주세요.

useState: 컴포넌트에서 상태를 관리하기 위한 Hook입니다. 배열 형태로 반환되는 값은 상태 값과 그 값을 변경할 수 있는 함수입니다.

useEffect: 컴포넌트가 렌더링된 후 부수 효과를 처리하기 위한 Hook입니다. 예를 들어, API 호출, 이벤트 리스너 등록, DOM 조작 등을 처리할 수 있습니다.

### useEffect와 useLayoutEffect의 차이에 대해 설명해 주세요.

useEffect: 렌더링 후에 비동기적으로 실행됩니다. DOM 업데이트 이후, 렌더링이 끝난 후 실행되므로 사용자에게 보이는 화면에 영향을 주지 않습니다.

useLayoutEffect: 렌더링 후 동기적으로 실행됩니다. DOM이 화면에 그려지기 전에 실행되므로, 레이아웃을 변경하거나 화면에 직접적인 영향을 미치는 작업을 처리할 때 사용합니다.

### useMemo, useCallback에 대해 설명하고, 어떤 경우에 사용하면 좋을지, 남용할 경우 발생할 수 있는 문제점을 설명해 주세요.

useMemo: 이 Hook은 계산 비용이 큰 값을 메모이제이션하여 불필요한 재계산을 방지합니다. 의존성 배열에 변화가 있을 때만 값을 다시 계산하고, 그렇지 않으면 이전 값을 재사용합니다. 렌더링 성능 최적화에 사용됩니다. 예를 들어, 복잡한 계산을 하는 함수가 있을 때 이 Hook을 사용하면 불필요한 계산을 피할 수 있습니다.

useCallback: 이 Hook은 함수를 메모이제이션하여, 의존성 배열이 변경되지 않으면 기존의 함수를 재사용합니다. 자식 컴포넌트에게 함수를 전달할 때, 함수가 불필요하게 재생성되는 것을 방지하는 데 유용합니다.

남용 시 문제점: useMemo와 useCallback은 메모리 사용을 증가시킬 수 있고, 너무 많은 경우에 사용하면 코드가 복잡해지고, 성능이 저하될 수 있습니다. 두 Hook은 주로 성능 최적화가 필요한 경우에만 사용하는 것이 좋습니다.

### React rendering 성능을 향상하기 위한 방법들을 설명해 주세요.

불필요한 렌더링을 방지: shouldComponentUpdate나 React.memo를 사용하여 불필요한 렌더링을 방지합니다.

useMemo, useCallback: 계산 비용이 큰 값이나 함수를 메모이제이션하여 불필요한 재계산을 방지합니다.

Lazy loading: 필요할 때만 컴포넌트를 로드하는 방법으로, 초기 로딩 속도를 개선할 수 있습니다.

### 재조정(Reconciliation) 개념에 대해서 설명해 주세요.

재조정은 리액트가 상태 변경이나 props 변경에 따라 변경된 DOM을 효율적으로 업데이트하는 알고리즘입니다. 리액트는 가상 DOM을 사용하여 이전 상태와 새로운 상태를 비교하고, 최소한의 변경을 실제 DOM에 반영하여 성능을 최적화합니다.

### React Lifecycle에 대해 설명해 주세요.

리액트 라이프사이클은 컴포넌트의 생애 주기 동안 호출되는 다양한 메서드를 의미합니다. 컴포넌트가 생성되고 마운트된 후, 상태 변경이나 props 변경에 따라 업데이트되고, 마지막으로 컴포넌트가 제거되는 과정이 포함됩니다. 주요 메서드로는 componentDidMount, shouldComponentUpdate, componentDidUpdate, componentWillUnmount 등이 있습니다.

### Props drilling의 개념과 Props drilling을 피하는 방법에 대해 설명해 주세요.

Props drilling은 데이터가 여러 단계의 컴포넌트를 거쳐 자식 컴포넌트로 전달되는 문제를 의미합니다. 이를 피하는 방법으로는 전역 상태 관리 도구(예: Redux, Context API 등)를 사용하는 것이 있습니다.

### 전역 상태 관리 방법에 대해 설명해 주세요.

전역 상태 관리 방법으로는 Redux, MobX, Recoil, Context API 등이 있습니다. 이들 도구는 애플리케이션의 상태를 중앙에서 관리하고, 여러 컴포넌트가 필요할 때 해당 상태를 공유할 수 있게 해줍니다.

### React에서 배열을 렌더링할 때 key를 설정해야 하는 이유를 설명해 주세요.

key는 배열 항목의 고유성을 식별하는 데 사용되며, 리액트가 리스트 항목을 효율적으로 업데이트할 수 있도록 도와줍니다. key가 없으면 리액트는 인덱스를 기본적으로 사용하고, 이로 인해 성능 문제가 발생하거나 불필요한 렌더링이 일어날 수 있습니다. key는 각 항목이 고유하도록 설정해야 최적화가 이루어집니다.
