## 1. useMemo, useCallback 에 대해 설명하고, 어떤 경우에 사용하면 좋을지, 남용할 경우 발생할 수 있는 문제점을 설명해 주세요.

### useMemo: 재렌더링 사이에 계산 결과를 캐싱할 수 있게 해주는 Hook

사용하면 좋은 경우

- 비용이 큰 계산을 반복하지 않아야 할 때
- 리렌더링이 자주 발생하고 데이터 변동이 적을 때
- 복잡한 계산 결과를 의존성으로 사용하는 경우

남용의 문제

- 코드 가독성 저하
- 의존성 배열 관리의 어려움
- 성능 오버헤드
- 불필요한 메모리 사용

---

### useCallback: 리렌더링 사이에 함수 정의를 캐싱하여 불필요한 함수 재생성을 방지하는 React Hook

사용히면 좋은 경우

- React.memo와 함께 사용할 때
- 비용이 큰 연산을 포함한 함수를 전달할 때
- useEffect와 함께 함수 의존성을 관리할 때
- React DevTools와 함께 사용할 때

남용의 문제

- 코드 복잡도 증가
- 불필요한 메모리 사용
- 잘못된 최적화
- 리액티브 값과의 의존성 문제
- 필요 이상으로 참조값 고정
- 디버깅 난이도 증가

---

### useMemo와 React.memo의 차이

| **특징**      | **useMemo**                               | **React.memo**                                          |
| ------------- | ----------------------------------------- | ------------------------------------------------------- |
| **주요 목적** | 비싼 계산 결과 캐싱                       | 컴포넌트 전체 리렌더링 방지                             |
| **적용 대상** | 특정 연산의 결과값                        | React 컴포넌트                                          |
| **사용 위치** | 컴포넌트 내부                             | 컴포넌트 외부 (`export default React.memo(...)`)        |
| **작동 조건** | 의존성 배열에 따라 계산된 값 반환         | props가 변경되지 않으면 이전 렌더링 결과 반환           |
| **사용 상황** | 복잡한 계산(비싼 연산)을 최적화할 때      | 부모 컴포넌트의 리렌더링이 자식 컴포넌트에 영향을 줄 때 |
| **공통점**    | 재사용 가능한 결과를 캐싱하여 성능 최적화 |                                                         |

---

### useMemo와 useCallback의 차이

| **특징**          | **useMemo**                                    | **useCallback**                          |
| ----------------- | ---------------------------------------------- | ---------------------------------------- |
| **캐싱하는 대상** | 계산 결과값 (Value)                            | 함수 (Function)                          |
| **사용 목적**     | 값이 비싼 계산을 최적화 (Memoized Computation) | 함수를 재사용하여 불필요한 리렌더링 방지 |
| **반환값**        | 계산된 결과값 (Primitive, Object 등)           | 메모이제이션된 함수 (Function)           |
