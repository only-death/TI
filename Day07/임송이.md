# React 면접질문 모음 (개념 익히기)

## Q. JSX에 대해 설명해 주세요.

> React에서 사용하는 Javascript 확장 문법.

JSX는 JavaScript XML의 약자로, JavaScript 코드 안에서 HTML과 유사한 마크업을 작성할 수 있게 해주는 React의 확장된 문법입니다.

- **JavaScript와 HTML의 결합:** JSX는 JavaScript 코드 안에 HTML 같은 마크업을 작성할 수 있게 해줍니다. 이를 통해 UI 구조와 관련 로직을 한 파일에서 함께 관리할 수 있습니다.
- **React.createElement()로 변환:** JSX 코드는 실제로는 브라우저가 직접 실행하지 않습니다. 바벨(Babel)과 같은 트랜스파일러에 의해 React.createElement() 함수 호출로 변환됩니다.
- **표현성과 가독성:** JSX는 HTML과 유사하기 때문에 UI 구조를 직관적으로 파악할 수 있어 가독성이 좋고, 중첩된 UI 컴포넌트를 표현하기 용이합니다.

## Q. React에서 배열을 렌더링할 때 key를 설정해야 하는 이유 컴포넌트

React에서 배열 요소를 렌더링할 때 key를 설정하는 이유는 React의 재조정(Reconciliation) 알고리즘이 효율적으로 작동하기 위해서입니다.
key(고유 식별자로) 배열의 변화를 정확히 파악해 변경된 부분만 업데이트 할 수 있게함. (Key가 없으면 다시 다그려야됨)

**key의 주요 역할은:**

- 각 요소의 고유한 ID로 작용하여 React가 변경, 추가, 삭제된 항목을 식별할 수 있게 합니다 (이전 배열과 비교)
- 리스트가 업데이트될 때 불필요한 DOM 조작을 최소화하여 성능을 최적화합니다
- 컴포넌트의 상태를 올바르게 유지하도록 도와줍니다

## Q. state와 props의 차이를 설명해 주세요.

state는 컴포넌트 내부에서 관리되는 변경 가능한 데이터이고, props는 부모 컴포넌트로부터 전달받는 읽기 전용 데이터입니다.

**Props (Properties):**

- 부모 컴포넌트로부터 자식 컴포넌트로 전달되는 읽기 전용 데이터
- 컴포넌트 외부에서 결정되며, 컴포넌트 내부에서 변경할 수 없습니다(immutable)
- 함수의 매개변수와 유사한 역할을 합니다
- 부모 컴포넌트가 리렌더링되면 자식 컴포넌트의 props도 새로운 값으로 업데이트됩니다

**State:**

- 컴포넌트 내부에서 관리되는 데이터로, 컴포넌트의 생명주기 동안 변경될 수 있습니다
- 사용자 상호작용, 네트워크 응답 등에 따라 동적으로 변경되는 데이터를 관리합니다
- 함수형 컴포넌트에서는 useState 훅을 통해, 클래스 컴포넌트에서는 this.state로 관리합니다
- state가 변경되면 컴포넌트는 리렌더링됩니다

**핵심 차이점:**

- 소유권: props는 부모 컴포넌트가 소유, state는 해당 컴포넌트가 소유
- 변경 가능성: props는 읽기 전용, state는 변경 가능
- 전달 방향: props는 하향식(top-down), state는 컴포넌트 내부에서 관리
  잘 설계된 컴포넌트는 props를 통해 필요한 데이터를 받고, 상호작용에 필요한 최소한의 state만 유지합니다.

## Q. state를 직접 변경하지 않고 setState를 사용하는 이유를 설명해 주세요.

React에서 state를 직접 수정하면 React가 변경을 감지하지 못해 리렌더링이 발생하지 않기 때문에, setState를 사용하여 상태를 변경해야 React가 변경을 인식하고 컴포넌트를 다시 렌더링할 수 있습니다.;

**setter함수 써야하는 이유**

- **리렌더링 트리거:** React는 setState가 호출될 때만 컴포넌트의 리렌더링을 예약합니다. 직접 state를 수정하면 React는 변경을 감지하지 못하고 UI가 업데이트되지 않습니다.
- **비동기적 처리:** setState는 비동기적으로 작동합니다. React는 여러 setState 호출을 batch 처리하여 성능을 최적화합니다.(리렌더링은 한번에 처리)
- **불변성 원칙:** 객체나 배열 같은 참조 타입의 경우, setState를 통해 새로운 참조를 생성합니다. 이를 통해 React가 이전 상태와 현재 상태를 정확하게 비교할 수 있습니다
- **예측 가능한 상태 변화:** setState를 사용하면 상태 변경이 일관된 방식으로 이루어져 코드의 동작을 예측하기 쉽습니다.
  디버깅과 유지보수가 용이해집니다.

setState를 올바르게 사용하면 React의 단방향 데이터 흐름을 유지하고 애플리케이션의 예측 가능성과 유지보수성을 향상시킬 수 있습니다.

## Q. React Hooks에 대해 설명해 주세요.

React Hooks는 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle)를 관리할수 있게 해주는 기능입니다.

**Hooks의 주요 목적:**

- 클래스 컴포넌트 없이 상태(useState)와 생명주기(useEffect) 관리 가능
- 컴포넌트 간 상태 로직 재사용 용이성 제공
- 관련 로직을 한 곳에서 관리하여 코드 가독성 향상
- this 키워드 관련 혼란 제거 (클로저를 활용하여 상태 관리)

**주요 내장 Hooks:**

- useState: 컴포넌트에 상태 추가
- useEffect: 생명주기 관련 기능 수행
- useContext: Context API 접근 간소화
- useReducer: 복잡한 상태 로직 관리
- useCallback, useMemo: 성능 최적화
- useRef: DOM 요소 참조 및 값 저장

**Hooks 사용 규칙:**

- Hook은 최상위에서만 호출해야 합니다
- 조건문이나 반복문 안에서 사용할 수 없습니다
- 이는 Hooks의 호출 순서를 보장하기 위함입니다

## Q. useState, useEffect에 대해 설명해 주세요.

useState 컴포넌트에서 상태를 관리할 수 있게 해주는 Hook으로, 상태 값과 그 값을 업데이트하는 함수를 반환합니다.
useEffect 컴포넌트의 렌더링 이후에 실행되는 부수 효과(side effects)를 처리하기 위한 Hook으로, 데이터 페칭 (API 호출), 구독 설정 (이벤트 리스너), DOM 조작 등을 수행할 수 있습니다.

_side effect: 컴포넌트의 주요 기능(렌더링) 외에 발생하는 모든 부수적인 작업_

React에서 컴포넌트의 주요 역할은 UI를 렌더링하는 것이고, 이외의 모든 작업들이 사이드 이펙트로 간주됩니다.<br>
이러한 사이드 이펙트는 useEffect 내에서 처리하는 것이 권장됩니다.

**useState**

- 초기 상태 값을 인자로 받고, 현재 상태와 상태를 업데이트하는 함수를 배열 형태로 반환
- 여러 개의 상태 변수를 독립적으로 관리
- 상태 업데이트 함수는 비동기적으로 작동하며, 이전 상태를 기반으로 업데이트할 때는 함수형 업데이트를 사용
- 객체나 배열 같은 복잡한 상태 변경 시 불변성을 유지

**useEffect**

- 컴포넌트가 렌더링된 후 실행됩니다 (componentDidMount, componentDidUpdate의 기능 결합)
- 두 번째 인자로 의존성 배열을 받아 특정 값이 변경될 때만 효과를 재실행
- 빈 의존성 배열([])을 전달하면 컴포넌트 마운트 시에만 실행
- 정리(cleanup) 함수를 반환하여 컴포넌트 언마운트 시 또는 다음 효과 실행 전에 정리 작업을 수행

## Q. useEffect와 useLayoutEffect의 차이에 대해 설명해 주세요.

useEffect와 useLayoutEffect는 둘 다 side effects를 처리하기 위한 React Hooks이지만, 중요 차이점은 실행 타이밍과 사용 목적에 있습니다.
useEffect는 브라우저가 화면을 그린 후 비동기적으로 실행되고 useLayoutEffect DOM 변경 직후, 브라우저가 화면을 그리기 전에 동기적으로 실행됩니다.
따라서 대부분의 경우 useEffect를 사용하고, 화면 깜빡임이 발생하는 등 레이아웃 계산이 필요한 경우에만 useLayoutEffect를 사용합니다.

**useEffect**

- 실행 타이밍: 비동기적으로 실행되며, 렌더링이 완료되고 화면이 업데이트된 후 실행
- 브라우저 페인팅: 브라우저가 화면을 그린 후 실행되므로 렌더링을 차단하지 않음
- 성능 영향: 대부분의 경우 성능에 영향을 덜 미침
- 적합한 사용 사례: 데이터 가져오기, 이벤트 리스너 등록, 로깅 등 화면 업데이트와 직접 관련이 없는 작업에 적합

**useLayoutEffect**

- 실행 타이밍: 동기적으로 실행되며, DOM 변경 후 브라우저가 화면을 그리기 전에 실행
- 브라우저 페인팅: 브라우저의 화면 그리기를 차단하므로 시각적 업데이트가 필요한 경우 유용
- 성능 영향: 실행이 오래 걸리면 화면 업데이트가 지연 될 수 있음
- 적합한 사용 사례: DOM 측정, 스크롤 위치 조정, 애니메이션 등 레이아웃 계산이 필요하거나 사용자에게 시각적 깜빡임을 방지해야 하는 작업에 적합
  (즉각적인 시각적 업데이트가 필요할 때만 사용)

**실무적 가이드라인:**

- 기본적으로 useEffect를 사용하고, 화면 깜빡임 등의 문제가 발생할 때만 useLayoutEffect로 전환하는 것이 좋습니다
- useLayoutEffect는 서버 사이드 렌더링에서 문제를 일으킬 수 있으므로 주의해야 합니다
- 성능 최적화를 위해 의존성 배열을 적절히 사용해야 합니다
  두 Hook의 API와 사용법은 동일하지만, 실행 타이밍의 차이로 인해 사용 사례가 명확히 구분됩니다.

## Q. React rendering 성능을 향상하기 위한 방법들을 설명해 주세요.

React의 렌더링 성능 최적화는 크게 세 가지 핵심 전략으로 요약할 수 있습니다. 첫째, React.memo나 useMemo, useCallback을 활용하여 불필요한 리렌더링을 방지하고, 둘째, 코드 분할(React.lazy)과 가상화(react-window) 기법을 통해 초기 로딩 시간과 메모리 사용량을 최적화하며, 마지막으로 상태 관리를 효율적으로 구조화하여 필요한 컴포넌트만 리렌더링되도록 설계하는 것입니다. 다만, 이러한 최적화 기법들은 실제로 성능 이슈가 발생하는 부분에 선택적으로 적용하는 것이 좋습니다.

**1. 불필요한 리렌더링 방지**

- React.memo: 동일한 props면 재사용 (컴포넌트 자체를 캐싱) → 부모가 리렌더링돼도 props가 같으면 자식은 리렌더링 안 함
- PureComponent: props/state 얕은 비교로 최적화 → 클래스형 컴포넌트에서 사용
- shouldComponentUpdate: 수동으로 비교 로직 작성 → 완전한 제어가 필요할 때
- key 속성: 리스트 렌더링 시 요소 식별 → index 대신 고유값 사용해야 함

**2. 상태 관리 최적화**

- 상태 정규화: 중첩 구조 피하기 → `{users: {byId: {}, allIds: []}}` 같은 형태로
- 불변성 유지: 상태 직접 수정 금지 → spread 연산자나 immer 사용
- 컴포넌트 트리 구조: 상태는 필요한 곳에만 → props drilling 피하기

**3. 계산 최적화**

- useMemo: 비용 큰 계산 결과 캐싱 → 복잡한 필터링, 정렬 등에 사용
- useCallback: 함수 자체를 캐싱 → 자식 컴포넌트에 props로 전달 시
- props 최소화: 필요한 것만 전달 → 객체 분해할당으로 필요한 것만

**4. 코드 분할 및 지연 로딩**

- React.lazy: 컴포넌트 동적 import → 초기 번들 크기 감소
  (React.lazy: 컴포넌트를 처음부터 다 불러오지 않고, 실제로 필요할 때만 불러오는 방식)
- 라우트 기반: 페이지별 분할 → 필요한 페이지만 로드
- Suspense: 컴포넌트가 로딩되는 동안 보여줄 대체 UI를 설정
- 지연 로딩: 큰 라이브러리 필요할 때만 → moment 같은 큰 패키지

**5. 가상화(Virtualization) 기법**

- react-window: 보이는 것만 렌더링 → 긴 리스트, 테이블에 효과적
  (1000개의 항목이 있다고 해도, 실제로 화면에 보이는 10-20개만 렌더링 / 스크롤할 때마다 보이는 항목만 교체하는 방식)
- 메모리 관리: DOM 노드 수 제한 → 브라우저 부하 감소 (가상화로 보이는 것만 DOM에 존재, 조건부 렌더링, 무한스크롤)

**6. 렌더링 우선순위 설정**

> useTransition과 useDeferredValue는 React 18에서 도입된 동시성(Concurrent) 기능

- useTransition: 긴급하지 않은 업데이트 지연 → 사용자 입력 같은 긴급 작업 방해 안 함 (우선순위 구분)

```JSX
const [isPending, startTransition] = useTransition();
// 요렇게 쌓은거 지연 가능 (비긴급)
 startTransition(() => {
      setResults(searchDatabase(e.target.value));
    });
```

- useDeferredValue: 값 업데이트 지연 → 중요한 업데이트가 먼저 처리되게 함 (ex. 실시간 변동값 (사용자 입력값))

**7. 개발 도구 활용**

- React DevTools: 리렌더링 추적 → 어떤 컴포넌트가 자주 리렌더링되는지 확인
- 성능 측정: 실제 사용자 경험 확인 → lighthouse 점수 개선

이러한 최적화 방법들은 애플리케이션의 복잡성과 규모에 따라 선택적으로 적용해야 하며, 과도한 최적화는 코드 복잡성을 증가시킬 수 있으므로 실제 성능 이슈가 확인된 경우에만 적용하는 것이 좋습니다.

## Q. useMemo, useCallback 에 대해 설명하고, 어떤 경우에 사용하면 좋을지, 남용할 경우 발생할 수 있는 문제점을 설명해 주세요.

useMemo와 useCallback은 React의 성능 최적화를 위한 Hook으로, useMemo는 계산 비용이 큰 값을, useCallback은 함수 참조를 메모이제이션하여 불필요한 리렌더링을 방지합니다. 하지만 모든 값이나 함수에 무분별하게 사용하면 메모리 사용량이 증가하고 코드 복잡성이 높아질 수 있으므로, 실제 성능 개선이 필요한 경우에만 선택적으로 사용하는 것이 좋습니다.

**useMemo**

- 메모이제이션된 값을 반환하는 Hook입니다
- 의존성 배열의 값이 변경될 때만 계산 함수를 재실행합니다
- 연산량이 많은 계산 결과를 캐싱하여 성능을 최적화합니다

**useCallback**

- 메모이제이션된 콜백 함수를 반환하는 Hook입니다
- 의존성 배열의 값이 변경될 때만 새 함수 인스턴스를 생성합니다
- 함수 참조의 안정성을 유지하여 불필요한 리렌더링을 방지합니다

**적절한 사용 시기**

**useMemo 사용 시기**

- 복잡한 계산이나 데이터 변환이 필요한 경우
- 렌더링 중 비용이 많이 드는 연산을 수행할 때
- 객체나 배열을 생성하여 자식 컴포넌트에 props로 전달할 때
- 의존성 배열에 포함된 값이 자주 변경되지 않을 때

**useCallback 사용 시기**

- 함수를 자식 컴포넌트에 props로 전달할 때 (특히 자식이 최적화된 컴포넌트일 경우)
- useEffect의 의존성 배열에 함수를 포함시켜야 할 때
- 이벤트 핸들러가 다른 hooks의 의존성으로 사용될 때
- 함수가 복잡한 로직을 포함하거나 클로저를 유지해야 할 때

**남용 시 문제점**

- **메모리 사용량 증가**: 모든 값과 함수를 메모이제이션하면 메모리 사용량이 증가합니다
- **코드 복잡성 증가**: 과도한 최적화는 코드 가독성과 유지보수성을 저하시킵니다
- **실제 성능 저하**: 단순한 연산이나 자주 변경되는 값에 사용하면 메모이제이션 오버헤드가 이득보다 클 수 있습니다
- **의존성 배열 관리 복잡성**: 의존성 배열을 제대로 관리하지 않으면 버그가 발생할 수 있습니다
- **최적화 효과 오인**: 실제 성능 병목점이 아닌 부분에 집중하여 중요한 최적화 기회를 놓칠 수 있습니다

**균형 잡힌 접근법**

- 실제 성능 문제가 확인된 경우에만 선택적으로 적용하세요
- React DevTools Profiler를 사용하여 최적화 효과를 측정하세요
- 단순한 값이나 함수는 메모이제이션 없이 직접 선언하는 것이 더 효율적일 수 있습니다
- 컴포넌트의 복잡성과 리렌더링 빈도를 고려하여 적용 여부를 결정하세요

## Q. 재조정(Reconciliation) 개념에 대해서 설명해 주세요.

재조정(Reconciliation)은 React가 가상 DOM과 실제 DOM을 비교하여 실제로 필요한 변경사항만 실제 DOM에 적용하는 과정입니다. React는 state나 props가 변경될 때 새로운 가상 DOM 트리를 생성하고, 이전 트리와 비교(diffing)하여 최소한의 업데이트만 수행함으로써 성능을 최적화합니다.

**재조정의 기본 원리**

- React는 상태나 props가 변경될 때마다 (=리렌더링 될떄마다~) 새로운 Virtual DOM 트리를 생성합니다
- 이 새로운 트리를 이전 트리와 비교하여 차이점(diff)을 찾습니다
- 실제 차이가 있는 부분만 실제 DOM에 업데이트합니다
- 이 과정을 통해 전체 DOM을 다시 그리는 것보다 효율적으로 UI를 업데이트합니다

**재조정 알고리즘의 핵심 가정**

1. **서로 다른 타입의 요소는 다른 트리를 생성합니다**:

   - 요소 타입(div, span, 컴포넌트 등)이 변경되면 해당 하위 트리 전체를 다시 구성합니다

2. **key prop으로 여러 렌더링 간에 안정적인 요소를 식별합니다**:
   - 리스트 항목에 고유하고 안정적인 key를 지정하면 React가 재배열, 추가, 삭제 작업을 효율적으로 처리할 수 있습니다

**재조정 과정의 단계**

1. **요소 타입 비교**: 타입이 다르면 이전 트리를 삭제하고 새 트리를 생성합니다
2. **같은 타입의 DOM 요소 비교**: 속성만 업데이트하고 자식 요소를 재귀적으로 처리합니다
3. **같은 타입의 컴포넌트 요소 비교**: 상태를 유지하고 props를 업데이트한 후 render() 메서드 결과를 재귀적으로 비교합니다
4. **자식 요소 재귀 처리**: key를 사용하여 효율적으로 자식 요소를 비교합니다

**재조정의 성능 영향**

- O(n) 복잡도: React는 휴리스틱 알고리즘을 사용하여 최적의 업데이트를 찾습니다
- Fiber 아키텍처: React 16부터 도입된 아키텍처로, 재조정 작업을 작은 단위로 나누어 중단 및 재개가 가능하도록 합니다
- 렌더링 최적화: shouldComponentUpdate, React.memo, PureComponent 등을 사용하여 불필요한 재조정을 방지할 수 있습니다

재조정에 대한 이해는 React 애플리케이션의 성능을 최적화하는 데 중요하며, key 속성의 올바른 사용과 불필요한 렌더링 방지가 핵심입니다.

## Q. React Lifecycle에 대해 설명해 주세요.

React의 생명주기는 컴포넌트가 생성(Mount), 업데이트(Update), 제거(Unmount)되는 전체 과정을 의미합니다. 클래스 컴포넌트에서는 componentDidMount, componentDidUpdate와 같은 메서드로 처리했지만, 현대의 함수형 컴포넌트에서는 useEffect 훅을 사용해 이러한 생명주기를 관리합니다. 예를 들어, useEffect의 빈 의존성 배열은 마운트 시점, 의존성 배열에 값이 있으면 업데이트 시점, 그리고 cleanup 함수는 언마운트 시점에 실행됩니다.

**클래스 컴포넌트의 생명주기**

1. **마운팅 단계** (컴포넌트가 DOM에 처음 삽입될 때)

   - constructor(): 컴포넌트 초기화, state 설정
   - static getDerivedStateFromProps(): props에서 state 파생
   - render(): JSX 반환
   - componentDidMount(): DOM 참조, 데이터 가져오기, 구독 설정

2. **업데이트 단계** (props 또는 state 변경으로 리렌더링될 때)

   - static getDerivedStateFromProps(): props 변화에 따른 state 업데이트
   - shouldComponentUpdate(): 리렌더링 여부 결정 (성능 최적화)
   - render(): 업데이트된 JSX 반환
   - getSnapshotBeforeUpdate(): DOM 변경 직전 정보 캡처
   - componentDidUpdate(): DOM 업데이트 후 작업, 이전 props/state 접근

3. **언마운팅 단계** (컴포넌트가 DOM에서 제거될 때)

   - componentWillUnmount(): 정리 작업, 구독 해제, 타이머 취소

4. **에러 처리**
   - static getDerivedStateFromError(): 하위 컴포넌트 에러 시 state 업데이트
   - componentDidCatch(): 에러 로깅, 에러 UI 표시

**함수형 컴포넌트의 생명주기 (Hooks 사용)**

함수형 컴포넌트는 Hooks를 통해 생명주기 기능을 구현합니다:

1. **마운팅 및 업데이트**

   - useState: 상태 관리
   - useEffect(callback, []): componentDidMount와 유사 (빈 의존성 배열)
   - useEffect(callback, [deps]): componentDidUpdate와 유사 (특정 의존성 변경 시)

2. **언마운팅 및 정리**

   - useEffect(()=>{ return cleanup }, []): componentWillUnmount와 유사 (정리 함수)

3. **최적화 및 메모이제이션**

   - useMemo: 계산된 값 메모이제이션 (shouldComponentUpdate와 유사한 최적화)
   - useCallback: 함수 인스턴스 메모이제이션

4. **레이아웃 효과**
   - useLayoutEffect: DOM 변경 후, 화면 갱신 전 실행 (동기적 실행)

**생명주기 메서드 사용 시 주의사항**

- render()와 함수형 컴포넌트 본문은 순수 함수여야 합니다
- 부수 효과는 useEffect나 해당 생명주기 메서드에서 처리해야 합니다
- 불필요한 리렌더링을 방지하기 위해 적절한 최적화가 필요합니다
- 언마운트 시 리소스 정리를 잊지 말아야 합니다

최신 React에서는 함수형 컴포넌트와 Hooks 사용을 권장하며, 클래스 컴포넌트의 복잡한 생명주기 메서드보다 더 직관적이고 재사용 가능한 패턴을 제공합니다.

## Q. Props drilling의 개념과 Props drilling을 피하는 방법에 대해 설명해 주세요.

**Props Drilling의 개념**

Props Drilling(또는 Prop Drilling)은 상위 컴포넌트에서 깊이 중첩된 하위 컴포넌트로 데이터를 전달하기 위해 중간 컴포넌트들을 통해 props를 계속해서 전달하는 과정을 말합니다.

예를 들어, A → B → C → D → E 컴포넌트 구조에서 A 컴포넌트의 데이터를 E 컴포넌트에서 사용해야 할 경우, B, C, D 컴포넌트는 자신이 직접 사용하지 않는 props를 단순히 E에 전달하기 위해 받아 전달하게 됩니다.

**Props Drilling의 문제점**

- 코드 가독성 저하: 중간 컴포넌트가 불필요한 props를 처리해야 함
- 유지보수 어려움: 데이터 흐름을 추적하기 어려워짐
- 컴포넌트 재사용성 감소: 특정 데이터에 의존하게 됨
- 불필요한 리렌더링: 중간 컴포넌트들이 변경되지 않은 props로 인해 리렌더링될 수 있음

**Props Drilling을 해결하는 방법**

1. **Context API 사용**

   - React의 Context API를 통해 컴포넌트 트리 전체에 데이터를 제공
   - 중간 컴포넌트를 거치지 않고 필요한 컴포넌트에서 직접 데이터 접근 가능
   - 적합한 사용 사례: 테마, 현재 사용자, 언어 설정 등 전역적으로 필요한 데이터

2. **상태 관리 라이브러리 사용**

   - Redux, Recoil, MobX, Zustand 등의 상태 관리 라이브러리 활용
   - 전역 상태 저장소를 통해 컴포넌트가 직접 필요한 데이터에 접근 가능
   - 적합한 사용 사례: 복잡한 상태 관리가 필요한 대규모 애플리케이션

3. **컴포넌트 구성(Composition) 활용**

   - children prop 또는 렌더 props 패턴을 사용하여 컴포넌트 구성
   - 데이터를 직접 전달하는 대신 컴포넌트를 구성하는 방식으로 해결
   - 적합한 사용 사례: UI 컴포넌트의 유연한 구성이 필요한 경우

4. **사용자 정의 Hooks 생성**

   - 관련 로직과 상태를 Hook으로 추출하여 필요한 컴포넌트에서 직접 사용
   - 로직 재사용성을 높이고 컴포넌트 간 의존성 감소
   - 적합한 사용 사례: 여러 컴포넌트에서 동일한 상태 로직이 필요한 경우

5. **컴포넌트 트리 구조 재설계**
   - 데이터 흐름에 맞게 컴포넌트 구조 최적화
   - 관련 상태를 사용하는 컴포넌트들을 공통 부모 아래 배치
   - 적합한 사용 사례: 명확한 데이터 흐름이 필요한 새 기능 개발 시

Props Drilling 문제 해결 시, 애플리케이션의 복잡성과 규모를 고려하여 적절한 방법을 선택하는 것이 중요합니다. 간단한 애플리케이션에서는 Context API가 적합할 수 있으며, 복잡한 상태 관리가 필요한 대규모 애플리케이션에서는 전문 상태 관리 라이브러리가 더 적합할 수 있습니다.

## Q. 전역 상태 관리 방법에 대해 설명해 주세요.

React의 전역 상태 관리는 크게 내장된 Context API와 외부 라이브러리인 Redux, Recoil 등을 활용하는 방식이 있는데, 저는 프로젝트의 규모와 복잡도에 따라 적절한 선택을 하는 것이 중요하다고 생각합니다. 작은 규모의 프로젝트에서는 Context API를 사용하여 간단하게 전역 상태를 관리하고, 큰 규모의 프로젝트에서는 Redux와 같은 라이브러리를 사용하여 예측 가능한 상태 흐름과 디버깅 용이성을 확보합니다.

**긴 버전**
React의 전역 상태 관리는 크게 내장된 Context API와 외부 라이브러리인 Redux, Recoil, Zustand, TanStack Query 등을 활용하는 방식이 있습니다. 저는 프로젝트의 규모, 상태 변경 빈도, 동기화 필요성에 따라 적절한 선택을 하는 것이 중요하다고 생각합니다.
작은 규모의 프로젝트에서는 Context API를 사용하여 간단하게 전역 상태를 관리할 수 있으며, 상태 변경이 자주 발생하지 않는 경우 적합합니다. 하지만 Context API는 렌더링 최적화가 어려운 단점이 있어, 무분별한 사용은 성능 문제를 초래할 수 있습니다.
큰 규모의 프로젝트에서는 Redux와 같은 라이브러리를 사용하여 예측 가능한 상태 흐름과 디버깅 용이성을 확보할 수 있습니다. 특히 **Redux Toolkit (RTK)**을 사용하면 보일러플레이트 코드를 줄이고, Immer를 활용한 불변성 관리가 쉬워집니다.
Recoil과 Zustand는 비교적 가벼운 상태 관리 라이브러리로, 비동기 데이터 관리나 컴포넌트 단위의 상태 공유가 필요한 경우 유용합니다.
TanStack Query는 전역 상태 관리라기보다는 서버 상태 관리 라이브러리지만, API 요청을 기반으로 한 데이터 캐싱과 동기화가 강력하여, 서버 상태는 TanStack Query, 클라이언트 UI 상태는 Context API나 Zustand를 활용하는 것이 일반적입니다.

### 각 방법의 특성 정리

**Context API**

- React 내장 기능, 간단한 설정
- 재렌더링 최적화 필요 (useMemo, useCallback, selector 활용)
- 상태 변경이 자주 일어나지 않는 경우 적합

**Redux / Redux Toolkit (RTK)**

- 예측 가능한 상태 흐름, 강력한 개발자 도구 (Redux DevTools)
- 불변성 관리 자동화 (Immer 포함)
- 비동기 처리 지원 (RTK Query)
- 대규모 프로젝트에 적합

**Recoil**

- React 친화적인 상태 관리
- 비동기 상태 관리(useRecoilValueLoadable) 용이
- Context API보다 효율적 (Recoil Atom 단위의 상태 관리)

**Zustand**

- Context API보다 가볍고, Redux보다 단순
- 선언형 API (Flux 패턴 필요 없음)
- 렌더링 최적화 (shallow 비교 및 선택적 구독)
- 중소 규모 프로젝트에서 사용하기 좋음

**TanStack Query**

- 서버 상태 (API 데이터) 캐싱 및 동기화
- 자동 재요청 및 에러 처리
- Redux의 useEffect + useState 패턴을 대체 가능

**실무에서는 보통 이렇게 선택합니다:**

- 서버 상태 (API 데이터) → TanStack Query
- UI/로컬 상태 → Context API, Redux Toolkit, Zustand
- 자주 변경되는 전역 상태 (예: 다크 모드, 유저 정보) → Zustand, Recoil
- 비즈니스 로직이 복잡한 앱 → Redux Toolkit + RTK Query
  이러한 기준을 가지고 선택하는 것이 중요하다고 생각합니다. 또한, 전역 상태를 무조건 사용하는 것이 아니라, 컴포넌트 내부에서 해결할 수 있는 상태는 최대한 지역 상태로 관리하는 것이 성능 최적화에 도움이 됩니다.

## etc.

### 자동 배치(Automatic Batching)

> React 18+ 도입
> 여러 상태 업데이트를 하나의 리렌더링으로 처리. 성능 개선

#### 이벤트 핸들러 내부

```JSX
function handleClick() {
setCount(c => c + 1); // 배치 처리됨
setFlag(f => !f); // 배치 처리됨
setValue(v => v + 1); // 배치 처리됨
// 위 세 개의 상태 업데이트는 하나의 리렌더링으로 처리됨
}

```

#### 비동기 콜백 내부

```JSX
setTimeout(() => {
  setCount(c => c + 1); // React 18에서는 배치 처리됨
  setFlag(f => !f);     // 배치 처리됨
  // 하나의 리렌더링으로 처리됨
}, 1000);
}

```

#### Promise 체인

```JSX
fetch(/*...*/).then(() => {
  setCount(c => c + 1); // React 18에서는 배치 처리됨
  setFlag(f => !f);     // 배치 처리됨
  // 하나의 리렌더링으로 처리됨
});

```

#### 네이티브 이벤트 핸들러

```JSX
element.addEventListener('click', () => {
  setCount(c => c + 1); // React 18에서는 배치 처리됨
  setFlag(f => !f);     // 배치 처리됨
  // 하나의 리렌더링으로 처리됨
});

```

- 배치 처리를 원하지 않는 특별한 경우에는 flushSync를 사용하여 즉시 업데이트를 강제 가능 (성능 별로..)
