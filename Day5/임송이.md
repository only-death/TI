# 1. var, let, const 를 서로 비교해 설명해 주세요.

## 중요 키워드

- 변수 선언 방식
- 스코프 (함수 스코프 vs 블록 스코프)
- 호이스팅
- 재선언과 재할당
- TDZ (Temporal Dead Zone)

## Script

`var`, `let`, `const` 키워드는 자바스크립트에서 변수를 선언하는 방식입니다.
먼저 스코프 측면에서 살펴보면, var는 함수 스코프를 가지고, let과 const는 블록 스코프를 가집니다. <br>
예를 들어, if문같은 블록 레벨에서 var로 변수를 선언하면 if문 밖에서도 접근할 수 있지만, let이나 const로 선언하면 if문 안에서만 사용할 수 있습니다.
호이스팅에 관해서는, var는 선언과 초기화가 함께 호이스팅되어 undefined로 초기화되지만, let과 const는 선언만 호이스팅되고 초기화는 코드 실행 시점에 이루어집니다. 그래서 var는 선언 전에 사용하면 undefined가 나오지만, let과 const는 에러가 발생합니다. 이것이 TDZ(Temporal Dead Zone)라고 불리는 현상입니다.
재선언과 재할당 측면에서는, var는 둘 다 가능하고, let은 재할당만 가능하며, const는 둘 다 불가능합니다.<br>
다만 원시값이 아닌 객체를 const로 선언했을 땐 객체 자체를 바꾸진 못해도 그 안의 속성은 바꿀 수 있습니다. (불변값 아님)
현대 JavaScript에서는 var보다 let과 const를 사용하는 것이 권장됩니다. 특히 값이 변경되지 않는 변수는 const를, 변경이 필요한 변수는 let을 사용하는 것이 좋습니다. 이렇게 하면 코드의 의도를 더 명확하게 표현할 수 있고, 예상치 못한 버그를 줄일 수 있습니다.

**실무 예시**

## 더 알아야할 내용

### Q. var를 사용하면 어떤 문제가 발생할 수 있나요?

var는 함수 스코프를 가지기 때문에 블록 내에서 선언해도 블록 외부에서 접근 가능합니다. 이로 인해 의도치 않은 변수 오염이 발생할 수 있습니다. 또한 var는 재선언이 가능하여 실수로 같은 이름의 변수를 다시 선언해도 오류가 발생하지 않아 디버깅이 어려울 수 있습니다.

### Q. const로 선언한 객체의 내부 속성은 변경할 수 없나요?

const는 변수의 재할당만 금지하고, 객체나 배열 같은 참조 타입의 내부 값은 변경할 수 있습니다. 객체의 내부 속성까지 불변으로 만들려면 Object.freeze()와 같은 메서드를 사용해야 합니다.

### Q. TDZ(Temporal Dead Zone)가 왜 중요한가요?

TDZ는 변수가 선언되었지만 아직 초기화되지 않은 상태를 말합니다. let과 const는 TDZ 기간 동안 변수에 접근하면 오류가 발생하므로, 변수를 사용하기 전에 반드시 선언과 초기화를 해야 합니다. 이는 코드의 예측 가능성을 높이고 버그를 줄이는 데 도움이 됩니다.

## 질문 의도

- JavaScript의 기본 개념에 대한 이해도
- 변수 선언 방식의 차이점을 정확히 알고 있는지
- 현대 JavaScript 개발 방식(ES6+)에 익숙한지
- 코드 품질과 버그 방지를 위한 최신 권장사항을 알고 있는지

---

# 2. 자바스크립트에서 this 키워드의 사용과 그 특성에 대해 설명해 주세요.

## 중요 키워드

- **현재 실행 중인 코드의 문맥(context)을 가리킴**
- 실행 컨텍스트 (Execution Context)
- 바인딩 (Binding) 방식
- 화살표 함수와 일반 함수의 차이
- call, apply, bind 메서드
- 이벤트 핸들러

## Script

this는 자바스크립트에서 현재 실행 중인 코드의 문맥(context)을 가리키는 특별한 키워드입니다. <br>
다른 언어들과 달리 자바스크립트에서는 this가 호출되는 방식에 따라 가리키는 대상이 동적으로 바뀝니다.
기본적으로 this가 결정되는 몇 가지 경우:<br>
**전역 범위**에서 this를 사용하면 브라우저에서는 window 객체, Node.js에서는 **global 객체**를 가리킵니다.
**일반 함수 내부**에서 this를 사용하면, 함수가 **어떻게 호출**됐느냐에 따라 달라집니다. 그냥 함수로 호출하면 역시 전역 객체를 가리킵니다. 단, 엄격 모드('use strict')에서는 undefined가 됩니다.
객체의 메서드로 호출될 때는 this가 그 메서드를 호출한 객체를 가리키게 됩니다. 예를 들어 user.sayHello()에서 sayHello 메서드 안의 this는 user 객체를 가리키는 것입니다.
**생성자 함수**로 new 키워드와 함께 호출될 때는 this가 **새로 생성된 인스턴스**를 가리킵니다.
**화살표 함수**는 좀 특별한데, 자기만의 this를 가지지 않고 선언된 시점의 **상위 스코프의 this**를 그대로 사용합니다. 이 덕분에 콜백 함수에서 바깥 스코프의 this를 유지할 때 유용하게 사용할 수 있습니다.
마지막으로 call(), apply(), bind() 같은 메서드를 사용하면 this를 명시적으로 지정할 수 있습니다. 특히 bind()는 함수의 this를 영구적으로 바꿔서 새 함수를 만들어주기 때문에 이벤트 핸들러 같은 곳에서 많이 사용합니다.
이처럼 this는 상황에 따라 다르게 바인딩되기 때문에, 자바스크립트에서 this를 사용할 때는 항상 현재 실행 컨텍스트가 무엇인지 생각해야 합니다

## 더 알아야할 내용

### Q. this 바인딩과 관련해서 흔히 발생하는 실수나 문제점은 무엇인가요?

콜백 함수에서 this가 예상과 다르게 동작하는 경우가 많습니다. 예를 들어 이벤트 리스너나 타이머 함수에서 this를 사용할 때, 의도한 객체 대신 전역 객체를 가리키게 되는 경우가 많습니다. 이럴 때 bind()를 사용하거나 화살표 함수를 활용하면 문제를 해결할 수 있습니다.

### Q. React에서 this를 사용할 때 주의해야 할 점은 무엇인가요?

React 클래스 컴포넌트에서는 이벤트 핸들러 메서드 안의 this가 컴포넌트 인스턴스를 가리키지 않는 문제가 자주 발생합니다. 이를 해결하기 위해 생성자에서 bind()를 사용하거나, 클래스 필드 문법과 화살표 함수를 사용하는 방법이 있습니다. 최근에는 함수형 컴포넌트와 Hooks를 사용하면서 this 관련 문제를 피할 수 있게 되었습니다.

### Q. 화살표 함수에서 this를 사용할 수 없는 상황이 있나요?

화살표 함수는 자신만의 this 바인딩이 없어서 객체의 메서드로 직접 정의할 때 주의해야 합니다. 특히 객체 메서드가 자기 자신(객체)을 참조해야 하는 경우, 화살표 함수를 사용하면 예상과 다르게 상위 스코프의 this를 가져오기 때문에 문제가 될 수 있습니다. 또한 생성자 함수로는 사용할 수 없고, prototype 메서드로도 적합하지 않습니다.

## 질문 의도

- 자바스크립트의 this 바인딩 규칙을 이해하고 있는지
- 다양한 함수 호출 방식에 따른 this의 차이를 알고 있는지
- 화살표 함수와 일반 함수의 차이점을 알고 있는지
- 실제 개발 시 this 관련 문제를 해결할 수 있는지

<br>

---

<br>

# 3. 렉시컬 스코프(Lexical Scope)의 개념과 그 특성에 대해 설명해 주세요.

## 중요 키워드

- 렉시컬 스코프 = 정적 스코프 (Static Scope) : 스코프 결정 방식
- 변수 결정 시점 : 선언문의 물리적 코드 위치
- 스코프 체인 (Scope Chain) : 안에서 바깥으로
- 렉시컬 환경: js엔진이 사용하는 데이터 구조. (환경 레코드(지역 변수 함수 선언 저장), 외부 렉시컬 환경 참조 (상위 렉시컬 스코프 참조))
- 클로저 (Closure)
- 중첩 함수 (Nested Functions)
- 변수 섀도잉 (Variable Shadowing)

## Script

렉시컬 스코프란 함수를 어디서 호출했는지가 아니라, **어디서 정의**했는지에 따라 **상위 스코프가 결정**되는 방식을 말합니다. 이는 '정적 스코프'라고도 불리는데, 코드가 작성된 그 문맥에서 스코프가 결정되기 때문입니다.
자바스크립트에서 이 렉시컬 스코프를 구현하는 메커니즘이 '렉시컬 환경'입니다. 렉시컬 환경은 자바스크립트 엔진이 사용하는 내부 데이터 구조로, 두 가지 핵심 요소로 구성됩니다. <br>
첫째는 '환경 레코드'로 현재 스코프의 모든 변수와 함수 선언을 저장하고, 둘째는 '외부 렉시컬 환경 참조'로 상위 스코프의 렉시컬 환경을 가리킵니다.
변수 참조 시 스코프 체인이 작동하는데, 자바스크립트 엔진은 현재 환경에서 변수를 찾고, 없으면 외부 렉시컬 환경으로 이동하며 계속 찾습니다. 이 과정이 전역 스코프까지 이어지는 것입니다.
클로저는 이런 렉시컬 스코프의 특성을 활용한 개념입니다. 함수가 자신이 선언된 렉시컬 환경을 기억하고, 나중에 다른 곳에서 실행되더라도 그 환경의 변수에 접근할 수 있는 것이죠.
중첩 함수에서는 내부 함수가 외부 함수의 변수에 접근할 수 있지만, 그 반대는 불가능합니다. 또한 변수 섀도잉이라는 현상도 있는데, 내부 스코프에서 선언된 변수가 같은 이름의 외부 변수를 가리는 것입니다.
이러한 렉시컬 스코프와 렉시컬 환경의 이해는 자바스크립트에서 변수 접근 방식과 클로저 같은 고급 개념을 활용하는 데 필수적입니다.

## 더 알아야할 내용

### Q. 렉시컬 스코프와 동적 스코프(Dynamic Scope)의 차이점은 무엇인가요?

렉시컬 스코프는 함수가 선언된 위치에 따라 상위 스코프가 결정되는 반면, 동적 스코프는 함수가 호출된 위치에 따라 상위 스코프가 결정됩니다. 자바스크립트는 기본적으로 렉시컬 스코프를 사용하지만, this 바인딩은 동적 스코프와 유사하게 동작합니다(화살표 함수 제외). 따라서 일반 함수의 this는 함수가 어떻게 호출되었는지에 따라 달라지는 것입니다.

### Q. 클로저(Closure)와 렉시컬 스코프의 관계를 설명해주세요.

클로저는 렉시컬 스코프의 특성을 활용한 개념입니다. 함수가 자신이 선언된 렉시컬 환경을 기억하고, 해당 환경의 변수들에 접근할 수 있는 것이 클로저입니다. 이는 함수가 자신의 렉시컬 스코프를 '닫아서(close)' 가지고 다닌다는 의미에서 클로저라고 합니다. 실제로 클로저는 비동기 처리, 데이터 캡슐화, 모듈 패턴 등 다양한 자바스크립트 패턴의 기초가 됩니다.

### Q. 렉시컬 스코프를 고려하여 코드를 작성할 때 주의해야 할 점은 무엇인가요?

렉시컬 스코프를 고려할 때는 변수의 이름 충돌(섀도잉)에 주의해야 합니다. 같은 이름의 변수가 다른 스코프에 존재하면 내부 스코프의 변수가 외부 변수를 가리기 때문입니다. 또한, 전역 스코프에 너무 많은 변수를 선언하면 이름 충돌과 메모리 문제가 발생할 수 있으므로 필요한 스코프 내에서만 변수를 선언하는 것이 좋습니다. 클로저를 사용할 때는 메모리 누수 가능성도 고려해야 합니다. 참조되지 않는 클로저는 가비지 컬렉션의 대상이 되도록 해야 합니다.

## 질문 의도

- 자바스크립트의 스코프 개념을 정확히 이해하는지
- 렉시컬 환경과 같은 내부 구현 메커니즘을 알고 있는지
- 클로저와 렉시컬 스코프의 연관성을 이해하는지
- 스코프를 고려한 코드 설계 능력이 있는지
