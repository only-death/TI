# 1. 리액트가 렌더링 하는 방식을 설명하세요.

## 중요 키워드

- Virtual DOM: 실제 브라우저 DOM의 가벼운 JavaScript 복사본 (객체)
- Render Phase & Commit Phase
- Reconciliation (재조정)
- Critical Rendering Path (CRP):브라우저가 HTML, CSS, JavaScript 파일을 화면에 픽셀로 변환하는 일련의 단계. (DOM생성, CCSS생성, 렌더트리, 레이아웃/ 리플로우, 페인팅)
- Re-rendering 조건: 상태(state) 변경, 부모 컴포넌트 리렌더링, props 변경, context값 변경

## Script

**간단 버전**

리액트는 VirtualDOM을 사용해서 DOM 조작의 최소한으로 하는 방식으로 렌더링을 합니다. 리액트 렌더링은 Render 단계와 Commit 단계 2가지 진행됩니다.
Render 단계에서는 첫 렌더링때 컴포넌트를 호출해서 React Element를 생성후 모아서 VirtualDOM을 생성합니다. 그 후 리렌더링이 될때마다 새로운 VirtualDOM을 생성하는데 이전 VirtualDOM과 비교 (differ)를 해서 변경사항을 저장하는 재조정 (Reconciliation)과정을 거칩니다.
Commit 단계에서는 실제로 계산된 변경 사항을 실제 DOM에 적용합니다. 첫 렌더링떄는 모든 DOM 노드를 생성하지만, 리렌더링에는 변경된 부분만 업데이트 하기 때문에 DOM 조작을 최소한으로 합니다.

**긴 맥락 버전**
리액트의 렌더링 방식을 이해하기 위해서는 브라우저의 기본 렌더링 과정(Critical Rendering Path)을 먼저 살펴볼 필요가 있습니다. 브라우저가 HTML과 CSS를 파싱하여 화면을 그리는 것처럼, 리액트도 자체적인 렌더링 프로세스를 통해 효율적으로 UI를 업데이트합니다.
이 과정의 핵심에는 Virtual DOM이 있습니다. Virtual DOM은 실제 DOM의 가벼운 복사본으로, 메모리에만 존재하는 자바스크립트 객체입니다. 실제 DOM 조작은 브라우저에 많은 비용이 드는 작업인데, Virtual DOM을 중간 단계로 활용함으로써 이러한 비용을 최소화할 수 있습니다.
리액트의 렌더링은 크게 두 단계로 진행됩니다:
**Render Phase**에서는 컴포넌트를 호출하여 React Element들을 생성하고, 이를 기반으로 Virtual DOM을 구성합니다. 상태가 변경되면 새로운 Virtual DOM을 생성하고, 이전 버전과 비교하는 재조정(Reconciliation) 과정을 수행합니다.<br>

이 과정에서 리액트는 효율적인 비교를 위해 몇 가지 규칙을 적용합니다:

- 같은 위치의 요소 타입이 동일하면 속성만 업데이트
- 타입이 다르면 해당 부분의 트리를 새로 생성
- 리스트 요소는 key를 통해 변경사항을 추적

**Commit Phase**에서는 앞서 계산된 변경사항을 실제 DOM에 적용합니다. 첫 렌더링 시에는 모든 DOM 노드를 생성하지만, 이후 리렌더링에서는 변경된 부분만 선택적으로 업데이트합니다.
이러한 렌더링 과정의 이해는 실제 개발에서 성능 최적화에 큰 도움이 됩니다. 예를 들어, 불필요한 리렌더링을 방지하기 위해 React.memo로 컴포넌트를 감싸거나, useMemo와 useCallback을 활용할 수 있습니다. 특히 대규모 리스트나 복잡한 계산이 필요한 컴포넌트에서는 이러한 최적화 기법이 필수적입니다.

**요약**
React는 Virtual DOM을 사용해 변경사항을 한번에 처리함으로서 브라우저 렌더링 과정을 여러번 반복하지 않도록 함. <br>
(실제 DOM 조작이 최소한으로 이루어져 CRP 중 비싼 연산인 Reflow와 paint 단계를 최적화).

**최신 트렌드**
또한 React 18에서 도입된 Concurrent Rendering과 같은 최신 기능은 렌더링 과정에 우선순위를 부여해 사용자 경험을 더욱 향상시킵니다. 이런 변화를 이해하고 적용하는 것이 현대 리액트 개발에서 중요하다고 생각합니다.

## 더 알아야할 내용

### Q. Virtual DOM이 실제로 성능 향상에 도움이 되는 이유는 무엇인가요?

- DOM 조작은 비용이 많이 드는 작업
- Virtual DOM은 변경사항을 모아서 한 번에 처리하여 실제 DOM 조작을 최소화
- 메모리상에서 동작하므로 실제 DOM 조작보다 빠름

### Q. React의 재조정(Reconciliation) 과정은 어떻게 이루어지나요?

- Diffing Algorithm을 사용하여 이전 Virtual DOM과 새로운 Virtual DOM을 비교
- 같은 위치의 엘리먼트 타입이 다르면 이전 트리를 버리고 새로운 트리 생성
- key prop을 통해 자식 엘리먼트들의 변경사항을 효율적으로 파악

### Q. 리액트의 렌더링 최적화 방법에는 어떤 것들이 있나요?

- React.memo를 사용한 컴포넌트 메모이제이션
- useMemo와 useCallback을 통한 값과 함수의 메모이제이션
- 상태 관리 시 불필요한 리렌더링을 유발하지 않도록 상태 구조 설계

## 질문 의도

- 리액트의 핵심 개념인 Virtual DOM과 렌더링 과정에 대한 이해도 파악
- 브라우저 렌더링과 리액트 렌더링의 관계 이해도 확인
- 성능 최적화에 대한 지식과 경험 확인

## 부가 정보

### Concurrent Rendering

- 기존 React의 렌더링은 "동기적(Synchronous)"으로 진행. (렌더링이 시작되면 완료될 때까지 중단되지 않음)
- Concurrent Rendering은 "비동기적(Asynchronous)"으로 작동.
  - **렌더링 작업 분할:** 큰 렌더링 작업을 작은 조각으로 분할
  - **우선순위 부여:** 각 작업에 우선순위 할당
  - **중단 및 재개:** 더 중요한 작업이 발생하면 현재 렌더링을 일시 중단하고 나중에 재개

### React Element

- React가 "무엇을 렌더링할지" 설명하는 JavaScript 객체
  (A lightweight object that serves as an instruction for React to render later.)
- 리액트 컴포넌트가 리턴하는 객체
- Virtual Dom을 구성하는 기본 단위
- 실제 DOM 노드를 가상으로 표현하는 **가벼운 객체**로, 메모리에만 존재

<br>

---

<br>

# 2. 리액트에서 Virtual DOM이 무엇인지, 이를 사용하는 이유는 무엇인지 설명해 주세요.

## 중요 키워드

- **Virtual DOM**: 실제 DOM의 가벼운 복사본으로, 메모리에만 존재하는 자바스크립트 객체

- **실제 DOM 조작 최소화**

- **재조정(Reconciliation)**: 이전 Virtual DOM과 새 Virtual DOM을 비교하여 변경사항을 파악하는 과정

- **배치 업데이트(Batch Update)**: 여러 상태 변경을 하나로 묶어 처리

  - React 18의 자동 배치: 이전에는 React 이벤트 핸들러 내에서만 배치 처리가 되었지만, React 18부터는 Promise, setTimeout, 네이티브 이벤트 핸들러 등 모든 상황에서 자동으로 배치 처리됨
  - 예: `setState()` 호출이 여러 번 있어도 한 번의 렌더링만 발생

- **Fiber 아키텍처**: React 16부터 도입된 재조정(Reconciliation) 엔진의 새로운 구현체
  - 렌더링 작업을 작은 단위로 나누어 우선순위 부여 가능
  - 작업을 중단/재개할 수 있어 브라우저 메인 스레드 차단 방지
  - React 18의 Concurrent Rendering의 기반 기술

## Script

Virtual DOM은 실제 DOM의 가벼운 복사본으로, 메모리에만 존재하는 자바스크립트 객체입니다. 리액트가 UI를 업데이트하는 과정에서 중간 단계 역할을 합니다.

Virtual DOM을 사용하는 주된 이유는 성능 최적화입니다. 실제 DOM 조작은 브라우저에서 비용이 많이 드는 작업인데, 특히 요소가 변경될 때마다 레이아웃 계산, 리페인트 등의 과정이 발생합니다.

리액트는 상태가 변경될 때마다 새로운 Virtual DOM 트리를 생성하고, 이전 트리와 비교하는 '재조정' 과정을 거칩니다. 이 과정에서 실제로 변경된 부분만 파악한 후, 모든 변경사항을 한 번에 실제 DOM에 적용합니다. 이렇게 함으로써 브라우저의 불필요한 렌더링 횟수를 줄이고 애플리케이션의 성능을 향상시킵니다.

예를 들어, 10개의 항목이 있는 리스트에서 한 항목만 변경된다면, 전체 리스트를 다시 그리는 대신 변경된 항목만 업데이트합니다.

## 더 알아야할 내용

### Q. Virtual DOM이 항상 빠른가요?

항상 그렇지는 않습니다. 간단한 UI나 업데이트가 적은 애플리케이션에서는 Virtual DOM의 오버헤드가 더 클 수 있습니다 (**VirtualDOM의 한계**). 최근에는 Svelte나 Solid.js 같은 프레임워크들이 컴파일 타임 최적화를 통해 Virtual DOM 없이도 효율적인 업데이트를 구현하고 있습니다.

예를 들어 Svelte는 컴파일 시점에 코드를 분석하여 '어떤 상태가 변경되면 어떤 DOM 요소가 영향을 받는지'를 미리 파악하고, 이에 맞는 최적화된 코드를 생성합니다. 이 방식은 재조정(diffing) 단계가 생략되어 성능 이점이 있고, 번들 사이즈도 작다는 장점이 있습니다. 다만 미리 DOM 업데이트 경로를 결정하기 때문에, 런타임에만 알 수 있는 정보에 대해서는 별도의 런타임 로직이 필요하다는 제약이 있습니다.
각 기술의 장단점을 이해하고 적절한 상황에 적용하는 것이 중요합니다.

### Q. Virtual DOM과 브라우저 렌더링 과정은 어떻게 연관되나요?

브라우저의 렌더링 과정(Critical Rendering Path)은 DOM 트리 구성, CSSOM 트리 구성, 렌더 트리 생성, 레이아웃 계산, 페인팅 단계로 이루어집니다. Virtual DOM은 이 중 DOM 트리 변경으로 인한 레이아웃 계산과 페인팅 단계의 반복을 최소화하여 성능을 개선합니다.

React 16부터 도입된 Fiber 아키텍처는 Virtual DOM의 내부 구현체로, 렌더링 작업을 작은 단위(fiber)로 나누어 우선순위를 부여하고 중단/재개할 수 있게 합니다. 이를 통해 브라우저의 메인 스레드를 차단하지 않고 렌더링 작업을 수행할 수 있어, 애니메이션이나 사용자 입력에 더 빠르게 반응할 수 있습니다. React 18의 Concurrent Rendering은 이 Fiber 아키텍처를 기반으로 구현되었습니다.

### Q. 최적화를 위해 개발자가 할 수 있는 일은 무엇인가요?

React에서는 불필요한 리렌더링을 방지하기 위해 여러 최적화 기법을 활용할 수 있습니다:

1. **메모이제이션**: React.memo로 컴포넌트를 감싸거나, useMemo와 useCallback 훅을 사용하여 값과 함수를 메모이제이션합니다.
2. **상태 관리 최적화**: 상태를 적절한 위치에 배치하고, 전역 상태는 필요한 부분만 구독하도록 설계합니다. Context API를 사용할 때는 상태를 논리적으로 분리하여 불필요한 리렌더링을 방지합니다.
3. **리스트 렌더링 최적화**: 대규모 리스트를 렌더링할 때는 react-window나 react-virtualized 같은 라이브러리를 사용한 windowing 기법을 적용하여 화면에 보이는 항목만 렌더링합니다.
4. **지연 로딩**: React.lazy와 Suspense를 사용하여 필요한 시점에 컴포넌트를 로드합니다.
5. **프로덕션 빌드 사용**: 개발 모드보다 프로덕션 빌드가 훨씬 성능이 좋으므로, 성능 측정은 항상 프로덕션 빌드로 진행합니다.

<br>

---

<br>

# 3. React에서 컴포넌트란 무엇이며, 함수형 컴포넌트와 클래스 컴포넌트의 차이점을 설명하세요.

## 중요 키워드

- Hooks
- 생명주기 메서드 (Lifecycle Methods)
- 재사용성 (Reusability)

## Script

React 컴포넌트는 UI를 독립적이고 재사용 가능한 조각으로 나눈 것으로, 자체적인 상태와 로직을 가질 수 있습니다. 컴포넌트는 React 애플리케이션의 기본 구성 요소로, 레고 블록처럼 조합하여 복잡한 UI를 구축할 수 있습니다.
함수형 컴포넌트는 JavaScript 함수로, props를 인자로 받아 React 엘리먼트를 반환합니다. React 16.8에서 Hooks가 도입되면서 상태 관리와 생명주기 기능도 사용할 수 있게 되었습니다. 간결하고 이해하기 쉬운 구문이 특징입니다.
클래스 컴포넌트는 ES6 클래스를 사용하며, React.Component를 상속받습니다. render 메서드가 필수이며, 생명주기 메서드를 통해 컴포넌트의 다양한 단계에 개입할 수 있습니다. this 키워드를 사용해 props와 state에 접근합니다.

**주요 차이점:**

- 함수형 컴포넌트는 Hooks를 통해 상태와 생명주기 기능을 사용하는 반면, 클래스 컴포넌트는 내장된 생명주기 메서드를 활용합니다.
- 함수형 컴포넌트는 this 바인딩 문제가 없고 코드가 더 간결합니다.
- 최적화 측면에서도 함수형 컴포넌트가 이점이 있습니다.
- 현대 React 개발에서는 함수형 컴포넌트와 Hooks를 사용하는 것이 권장됩니다.

# 더 알아야할 내용

### Q. React Hooks의 규칙은 무엇인가요?

- Hooks는 항상 컴포넌트의 최상위 레벨에서만 호출해야 함 <br>
  (조건문, 반복문, 중첩 함수 내에서 호출 ❌ React가 Hooks의 호출 순서에 의존하여 상태를 추적하기 때문)
- Hooks는 React 함수 컴포넌트 또는 커스텀 Hooks 내에서만 호출해야 함 (일반 JavaScript 함수에서는 사용 ❌)
- ESLint 플러그인을 사용하여 규칙 준수 확인 가능

### Q. 클래스 컴포넌트에서 함수형 컴포넌트로 마이그레이션하는 전략은 무엇인가요?

- 점진적 마이그레이션이 안전한 접근법
- 생명주기 메서드는 useEffect로 대체 가능
- 상태 로직 재사용을 위해 커스텀 Hooks 활용

점진적 마이그레이션이 가장 안전한 접근법입니다. 먼저 새로운 컴포넌트는 함수형으로 작성하고, 기존 클래스 컴포넌트는 우선순위에 따라 변환합니다. 복잡한 생명주기 메서드를 사용하는 컴포넌트는 useEffect를 여러 개 사용하여 분리할 수 있습니다.

componentDidMount, componentDidUpdate, componentWillUnmount는 각각 useEffect로 대체할 수 있으며, getDerivedStateFromProps는 일반적으로 useState와 useEffect의 조합으로 구현할 수 있습니다. 상태 로직 재사용을 위해 커스텀 Hooks를 만들면 코드 중복을 줄이고 관심사를 분리할 수 있습니다.

### Q. 함수형 컴포넌트의 성능 최적화 방법은 무엇인가요?

- React.memo를 사용하여 불필요한 리렌더링 방지
- useMemo와 useCallback으로 계산 비용이 큰 연산이나 함수 참조 메모이제이션
- deps 배열을 올바르게 관리하여 불필요한 실행 방지
