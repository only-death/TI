# 1. TypeScript의 동작 원리에 대해 설명해 주세요.

## 중요 키워드

- 정적 타입 검사(Static Type Checking)
- 트랜스파일링(Transpiling)
- 타입 소거(Type Erasure)
- TSC(TypeScript Compiler)
- 타입 추론(Type Inference)

## Script

**짧은 말하기**
TypeScript는 JavaScript에 정적 타입 시스템을 추가한 언어로, 개발 단계에서 타입 검사를 수행한 후 JavaScript로 트랜스파일됩니다. 이 과정에서 타입 정보는 완전히 제거되는 '타입 소거' 원칙이 적용되어, 런타임에는 일반 JavaScript와 동일하게 동작합니다. 이는 개발 경험과 코드 품질은 향상시키면서도 성능 오버헤드를 최소화하는 설계입니다.

**풀어서 말하기**
TypeScript는 JavaScript의 슈퍼셋 언어로, 정적 타입 시스템을 JavaScript에 추가하여 개발 단계에서 타입 관련 오류를 조기에 발견할 수 있게 해줍니다. TypeScript의 핵심 동작 원리는 2단계로 이루어집니다.

첫째, 코드 작성과 빌드 시점에 정적 타입 검사를 수행합니다. 컴파일러는 타입 선언과 타입 추론을 통해 코드의 타입 안정성을 검증하고, 잠재적 오류를 찾아냅니다. 이 과정에서 TypeScript는 구조적 타이핑(structural typing)을 사용하여 객체의 형태에 기반한 타입 호환성을 검사합니다.

둘째, 검사가 완료된 TypeScript 코드는 트랜스파일 과정을 통해 브라우저가 이해할 수 있는 JavaScript로 변환됩니다. 이 과정에서 타입 정보는 모두 제거되는 '타입 소거' 원칙이 적용되며, 결과적으로 실행 시점에는 일반 JavaScript와 동일하게 동작합니다. 이러한 설계는 성능 오버헤드 없이 개발 경험을 향상시키는 균형점을 제공합니다.

- **정적 타입 검사 (컴파일 타임)**

  - 코드 작성 시 타입 오류를 즉시 발견
  - 구조적 타이핑(형태 기반 타입 호환성) 사용
  - 타입 추론으로 명시적 선언 없이도 타입 결정

- **트랜스파일링 과정**

  - TS → JS 변환 (타입 소거)
  - 타입 정보는 런타임에 존재하지 않음
  - 결과물은 순수한 JavaScript

- **컴파일러 구조**

  - 파서(Parser) → AST 생성
  - 바인더(Binder) → 심볼 테이블 구축
  - 타입 체커(Type Checker) → 타입 검증
  - 에미터(Emitter) → JS 코드 생성

- **실무 적용 이점**
  - 리팩토링 안전성 확보
  - IDE 지원 강화(자동완성, 타입 힌팅)
  - `tsconfig.json`을 통한 점진적 타입 강화

## 더 알아야할 내용

### Q. TypeScript의 타입 시스템이 JavaScript 런타임 성능에 미치는 영향은 무엇인가요?

TypeScript의 타입 시스템은 컴파일 타임에만 존재하며, 트랜스파일 과정에서 모든 타입 정보가 제거됩니다(타입 소거). 따라서 런타임에는 일반 JavaScript와 동일하게 실행되어 성능 오버헤드가 없습니다. 다만, 빌드 시간이 증가할 수 있고, 제너레이터나 데코레이터와 같은 메타프로그래밍 기능 사용 시 추가 코드가 생성될 수 있습니다.

### Q. TypeScript의 타입 추론 메커니즘은 어떻게 작동하나요?

TypeScript의 타입 추론은 코드 흐름 분석(flow analysis)을 통해 작동합니다. 변수 초기화, 함수 반환 값, 조건문 내의 타입 가드 등을 분석하여 명시적 타입 선언 없이도 타입을 결정합니다. 또한 변수 사용 위치를 분석하는 문맥적 타이핑(contextual typing)을 적용해 콜백 함수 등에서 매개변수 타입을 추론합니다. 이러한 추론 시스템은 제네릭을 통해 더욱 강화되어, 함수나 클래스가 다양한 타입과 작동하면서도 타입 안전성을 유지할 수 있게 합니다.

### Q. TypeScript 컴파일러(TSC)의 내부 구조는 어떻게 되어 있나요?

TypeScript 컴파일러는 크게 파서(Parser), 바인더(Binder), 타입 체커(Type Checker), 에미터(Emitter)로 구성됩니다. 파서는 소스 코드를 AST(추상 구문 트리)로 변환하고, 바인더는 식별자와 선언을 연결하는 심볼 테이블을 구축합니다. 타입 체커는 이 심볼 테이블을 사용해 타입 검사를 수행하고, 마지막으로 에미터가 AST를 JavaScript 코드로 변환합니다. 이 모듈화된 아키텍처 덕분에 컴파일러 API를 통해 프로그래밍 방식으로 컴파일 과정을 제어할 수 있으며, 이는 Babel, ESLint, Prettier 같은 도구와의 통합을 가능하게 합니다.

<br>

<br>

# 2. d.ts 타입 정의파일이 무엇이며, 어떻게 만들 수 있는지 설명하세요.

## 중요 키워드

- 선언 파일(Declaration Files)
- 타입 정의(Type Definitions)
- Definitely Typed (@types/\*)
- 앰비언트 선언(Ambient Declarations)
- 모듈 증강(Module Augmentation)

## Script

**짧은 말하기**
d.ts 파일은 JavaScript 코드에 대한 타입 정보를 제공하는 TypeScript 선언 파일로, JavaScript 라이브러리를 TypeScript에서 안전하게 사용할 수 있게 해줍니다. 이 파일은 구현 코드 없이 타입 시그니처만 포함하며, 기존 JavaScript 코드를 변경하지 않고도 타입 시스템의 이점을 누릴 수 있게 합니다. 직접 작성, tsc 컴파일러 사용, 또는 외부 도구를 통해 생성할 수 있습니다.

**풀어서 말하기**
d.ts 파일은 JavaScript 코드의 타입 정보를 제공하는 TypeScript 선언 파일입니다. 이 파일들은 JavaScript 라이브러리나 모듈을 TypeScript 환경에서 타입-세이프하게 사용할 수 있게 해주는 인터페이스 역할을 합니다.

d.ts 파일의 핵심 가치는 기존 JavaScript 코드베이스를 직접 수정하지 않고도 TypeScript의 타입 검사 혜택을 받을 수 있게 하는 데 있습니다. 타입 정의 파일은 코드 구현 없이 타입 시그니처만 포함하며, 정적 타입 검사와 IDE 자동 완성 기능을 가능하게 합니다.

d.ts 파일 생성 방법에는 세 가지 주요 접근법이 있습니다. 첫째, 직접 수동으로 작성하는 방법입니다. 둘째, tsc 컴파일러의 --declaration 플래그를 사용해 자동 생성하는 방법이 있습니다. 셋째, dts-gen 같은 외부 도구를 활용해 JavaScript 라이브러리에서 선언 파일을 생성할 수 있습니다.

**실무 예시**

실무에서는 자사 서비스의 내부 JavaScript 유틸리티 라이브러리에 d.ts 파일을 추가하여 TypeScript 마이그레이션을 점진적으로 수행했습니다. 특히 `JSDoc` 주석이 있는 기존 코드를 활용해 `tsc --allowJs --declaration --emitDeclarationOnly` 옵션으로 초기 타입 정의를 생성한 후, 수동으로 정밀하게 조정했습니다.

또한 제3자 라이브러리가 자체 타입 정의를 제공하지 않을 경우, 프로젝트 내 `types` 폴더에 모듈 증강(module augmentation)을 사용하여 커스텀 타입 정의를 작성했습니다. 이 접근법은 `@types` 패키지가 존재하지 않거나 불완전한 경우 유용했으며, IDE 지원과 타입 안전성을 확보하는 데 핵심적이었습니다.

## 핵심 포인트

- **d.ts 파일의 용도**

  - JavaScript 코드/라이브러리에 타입 정보 제공
  - 코드 변경 없이 TypeScript 기능 활용
  - IDE 자동완성과 타입 검사 지원

- **생성 방법**

  - 수동 작성: 직접 타입 정의 작성
  - tsc 컴파일러: `--declaration` 플래그 사용
  - 외부 도구: dts-gen 등 활용

- **실무 적용 사례**

  - 기존 JS 라이브러리 타입 정의 추가
  - JSDoc + `--emitDeclarationOnly` 활용
  - 모듈 증강으로 서드파티 라이브러리 확장

- **생태계 통합**
  - DefinitelyTyped/`@types` 패키지 활용
  - 모듈 증강(module augmentation) 기법
  - 전역 증강(global augmentation)으로 확장

## 더 알아야할 내용

### Q. 모듈 증강(Module Augmentation)과 전역 증강(Global Augmentation)의 차이점은 무엇인가요?

모듈 증강은 기존 모듈에 새로운 타입이나 인터페이스를 추가할 때 사용하며, `declare module "모듈명"` 구문으로 시작합니다. 이는 특정 라이브러리의 타입 정의를 확장할 때 유용합니다. 반면 전역 증강은 `declare global { }` 블록을 사용해 전역 네임스페이스에 타입을 추가합니다. 예를 들어, Window 객체나 Array 프로토타입에 커스텀 프로퍼티를 추가할 때 사용합니다. 두 방법 모두 기존 타입 정의를 침해하지 않으면서 확장할 수 있는 방법을 제공하지만, 적용 범위와 임포트 방식에서 차이가 있습니다.

### Q. DefinitelyTyped 프로젝트와 @types 패키지의 관계는 무엇인가요?

DefinitelyTyped는 타입 정의 파일을 위한 오픈 소스 저장소로, 커뮤니티가 다양한 JavaScript 라이브러리에 대한 d.ts 파일을 기여하고 관리합니다. @types는 이 저장소의 타입 정의를 npm 패키지로 제공하는 네임스페이스입니다. 예를 들어, `@types/react`는 React의 타입 정의를 포함합니다. TypeScript 2.0부터는 `tsconfig.json`의 `typeRoots` 및 `types` 옵션을 통해 이러한 패키지를 자동으로 인식하며, npm을 통한 간편한 설치와 버전 관리가 가능합니다. 이 생태계는 TypeScript 채택을 크게 촉진했으며, 대부분의 주요 라이브러리에 대한 타입 지원을 제공합니다.

### Q. d.ts 파일에서 타입과 값의 네임스페이스를 어떻게 구분하나요?

TypeScript는 타입 네임스페이스와 값 네임스페이스를 분리하여 관리합니다. `interface`, `type`과 같은 구문은 타입 네임스페이스에만 존재하고, 런타임에는 사라집니다. 반면 `class`, `enum`, `const`, `namespace`는 값 네임스페이스에도 존재합니다. d.ts 파일에서는 `declare` 키워드를 사용해 값을 정의할 수 있으며, 타입과 값이 동일한 이름을 공유할 수도 있습니다(예: class와 interface). 이러한 이중성을 이해하는 것은 특히 제네릭 클래스 또는 네임스페이스가 포함된 복잡한 라이브러리의 타입 정의를 작성할 때 중요합니다. 예를 들어 `React.Component`는 값(클래스)이면서 동시에 타입(제네릭 인터페이스)으로 사용됩니다.
