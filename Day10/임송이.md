# 1. MVC(Model-View-Controller) 패턴이란 무엇인가요? 이 패턴의 각 구성 요소의 역할을 설명하고, MVC 패턴을 사용하는 이유와 그 장점에 대해 서술해주세요.

## 중요 키워드

- 관심사의 분리(Separation of Concerns)
- 모델(Model), 뷰(View), 컨트롤러(Controller)
- 유지보수성, 확장성, 재사용성
- 단위 테스트 용이성
- 디자인 패턴

## Script

MVC는 애플리케이션을 세 가지 주요 컴포넌트로 분리하는 아키텍처 패턴입니다. Model은 데이터와 비즈니스 로직을 관리하고, View는 사용자 인터페이스를 담당하며, Controller는 사용자 입력을 처리하여 Model과 View 간의 중재자 역할을 합니다. 이러한 관심사 분리를 통해 코드의 유지보수성과 재사용성이 향상되고, 팀 협업이 용이해지며, 테스트하기 쉬운 코드 구조를 제공합니다.

### 각 구성 요소의 역할:

1. **모델(Model)**:

   - 데이터와 비즈니스 로직을 담당합니다.
   - 애플리케이션에서 처리해야 할 데이터 형식을 정의하고, 데이터를 관리하거나 상태를 변경합니다.
   - 뷰나 컨트롤러에 대해 독립성을 유지하며 데이터 관련 모든 로직을 처리합니다.
   - 데이터가 변경될 때 이를 뷰에 알려 최신 데이터를 반영할 수 있게 합니다(옵저버 패턴).

2. **뷰(View)**:

   - 사용자 인터페이스(UI)를 담당합니다.
   - 모델로부터 데이터를 받아와 화면에 시각적으로 표현합니다.
   - 모델의 상태가 변하면 자동으로 화면을 업데이트합니다.
   - 사용자의 입력을 받아 컨트롤러에 전달합니다.

3. **컨트롤러(Controller)**:
   - 모델과 뷰를 연결하는 중재자 역할을 합니다.
   - 사용자가 뷰에서 입력한 데이터를 처리하고, 그에 맞는 동작을 모델에 전달하여 상태를 변경합니다.
   - 모델의 상태가 업데이트되면 이를 뷰에 전달해 화면을 갱신합니다.

### MVC 패턴을 사용하는 이유와 장점:

1. **유지보수 용이성**:

   - 애플리케이션의 기능과 UI가 분리되어 있어 각 부분을 독립적으로 수정할 수 있습니다.
   - 모델의 비즈니스 로직을 수정할 때 UI를 변경할 필요가 없습니다.

2. **단위 테스트 용이성**:

   - 비즈니스 로직이 모델에 집중되어 있어 단위 테스트 작성이 용이합니다.
   - 뷰와의 의존성을 최소화하여 테스트가 독립적이고 명확하게 이루어질 수 있습니다.

3. **팀 개발에서의 효율성**:

   - 관심사 분리를 통해 개발자들이 독립적으로 작업할 수 있습니다.
   - 백엔드 개발자는 모델과 비즈니스 로직을, 프론트엔드 개발자는 뷰와 UI를 담당할 수 있습니다.

4. **확장성 및 유연성**:

   - 새로운 기능이나 UI 변경을 추가할 때 기존 코드를 최소한으로 수정하면서 확장할 수 있습니다.
   - UI와 비즈니스 로직이 분리되어 있어 새로운 UI로의 대체가 용이합니다.

5. **재사용성**:
   - 동일한 모델에 여러 뷰를 적용할 수 있어 재사용성이 뛰어납니다.
   - 같은 모델을 사용하여 다양한 UI를 제공하거나, 다른 컨트롤러에서 모델을 활용할 수 있습니다.

**실무 예시**

웹 애플리케이션에서 사용자 등록 기능을 구현한다고 가정해보겠습니다:

- **모델**: User 모델은 사용자 데이터(이름, 이메일, 비밀번호 등)를 정의하고, 데이터베이스와의 상호작용, 유효성 검사 등의 비즈니스 로직을 처리합니다.
- **뷰**: 회원가입 폼을 화면에 표시하고, 사용자 입력을 받아 컨트롤러에 전달합니다. 또한 모델로부터 피드백(예: 유효성 검사 오류)을 받아 사용자에게 표시합니다.
- **컨트롤러**: 뷰로부터 사용자 입력 데이터를 받아 모델의 적절한 메서드를 호출하고, 그 결과에 따라 적절한 뷰를 사용자에게 제공합니다(성공 시 로그인 페이지, 실패 시 오류 메시지와 함께 회원가입 폼).

## 더 알아야할 내용

### Q. MVC 패턴과 다른 아키텍처 패턴(예: MVVM, MVP)의 차이점은 무엇인가요?

MVC는 Controller가 View와 Model 사이에서 중재자 역할을 하는 반면, MVVM은 ViewModel이 View와 Model 사이에서 데이터 바인딩을 통해 상호작용하고, MVP는 Presenter가 View와 Model 사이의 모든 상호작용을 관리합니다. MVVM은 특히 데이터 바인딩 기능을 통해 View와 ViewModel 간의 자동 동기화를 제공하여 코드를 더 간결하게 만듭니다.

### Q. 프론트엔드 프레임워크(React, Angular, Vue 등)에서 MVC 패턴은 어떻게 적용되나요?

현대 프론트엔드 프레임워크들은 전통적인 MVC보다 변형된 형태를 사용합니다. React는 주로 View 레이어에 집중하며, 상태 관리 라이브러리(Redux 등)로 Model 부분을 처리합니다. Angular는 컴포넌트, 서비스, 모듈로 구성된 더 복잡한 구조를 가지며 MVVM에 가깝습니다. Vue는 MVVM 패턴을 따르지만 컴포넌트 기반 아키텍처로 단순화되었습니다.

### Q. MVC 패턴의 단점이나 한계점은 무엇이 있을까요?

MVC 패턴은 애플리케이션 규모가 커질수록 Controller가 비대해지는 "Fat Controller" 문제가 발생할 수 있습니다. 또한 양방향 데이터 흐름으로 인해 복잡한 애플리케이션에서는 데이터 흐름을 추적하기 어려울 수 있습니다. 현대 웹 애플리케이션의 복잡성이 증가함에 따라, 단방향 데이터 흐름을 가진 Flux/Redux 같은 패턴이 더 선호되기도 합니다.

<br>

<br>

# OAuth란 무엇인가요? 그리고 왜 사용하는지 설명해주세요.

## 중요 키워드

- 인증(Authentication)과 인가(Authorization)
- 토큰 기반 인증(Token-based Authentication)
- 제3자 접근 권한 관리(Third-party Access)
- 리소스 소유자(Resource Owner), 클라이언트(Client), 리소스 서버(Resource Server)
- OAuth 2.0, OpenID Connect

## Script

OAuth는 사용자가 자신의 비밀번호를 공유하지 않고도 제3자 애플리케이션에 제한된 접근 권한을 부여할 수 있는 인증 프로토콜입니다. 이는 토큰 기반으로 작동하며, 주로 소셜 로그인이나 API 접근 권한 관리에 사용됩니다. OAuth를 사용하면 보안이 강화되고, 사용자 경험이 개선되며, 서비스 간 안전한 데이터 교환이 가능해집니다.

### OAuth의 기본 개념

OAuth는 사용자가 자신의 계정 정보(사용자 이름과 비밀번호)를 서비스에 직접 제공하지 않고도 다른 서비스의 기능을 이용할 수 있도록 해주는 인증 프로토콜입니다. 이것은 "위임된 인증"이라는 개념에 기반합니다.

### OAuth를 사용하는 주요 이유

1. **보안 강화**:

   - 사용자는 제3자 애플리케이션에 직접 자신의 계정 정보를 제공할 필요가 없습니다.
   - 토큰은 제한된 접근 권한만을 부여하며, 필요에 따라 쉽게 취소할 수 있습니다.

2. **접근 제어의 세분화**:

   - 애플리케이션은 필요한 권한만 요청할 수 있으며, 사용자는 어떤 권한을 부여할지 선택할 수 있습니다.
   - 예: 프로필 읽기, 사진 업로드, 이메일 접근 등 특정 권한만 부여할 수 있습니다.

3. **안전한 서비스 통합**:

   - 기업은 내부 데이터를 안전하게 보호하면서도 다양한 서비스와 통합할 수 있습니다.
   - API를 통한 서비스 간 안전한 데이터 교환이 가능합니다.

4. **사용자 경험 개선**:
   - 사용자는 여러 서비스에 각각 계정을 만들지 않고도 기존 계정으로 로그인할 수 있습니다.
   - "소셜 로그인" 기능을 통해 회원가입 과정이 간소화됩니다.

### OAuth 2.0 동작 방식

OAuth 2.0의 기본적인 역할과 동작 과정은 다음과 같습니다:

1. 클라이언트가 리소스 소유자에게 승인을 요청합니다.
2. 리소스 소유자가 승인하면 인증 코드가 발급됩니다.
3. 클라이언트는 이 인증 코드를 인증 서버에 제출하여 액세스 토큰을 요청합니다.
4. 인증 서버는 액세스 토큰을 발급합니다.
5. 클라이언트는 액세스 토큰을 사용하여 리소스 서버에 보호된 자원을 요청합니다.
6. 리소스 서버는 토큰을 검증하고 요청된 자원을 제공합니다.

**실무 예시**

대표적인 OAuth 구현 사례로는 "소셜 로그인" 기능이 있습니다:

1. **사용자 경험**:

   - 사용자가 새로운 앱에서 "구글로 로그인" 버튼을 클릭합니다.
   - 구글 로그인 페이지로 리디렉션되고, 사용자가 로그인합니다.
   - 구글은 앱이 요청한 권한 목록(이메일, 프로필 정보 등)을 보여주고 사용자에게 승인을 요청합니다.
   - 사용자가 승인하면 원래 앱으로 돌아가고, 앱은 이제 구글 API를 통해 사용자 정보에 접근할 수 있습니다.

2. **구현 관점**:
   - 개발자는 먼저 구글 개발자 콘솔에 앱을 등록하고 클라이언트 ID와 시크릿을 발급받습니다.
   - 앱 서버에서는 OAuth 라이브러리를 사용하여 인증 요청을 생성하고 리디렉션 URI를 설정합니다.
   - 콜백 URI에서는 인증 코드를 받아 액세스 토큰으로 교환합니다.
   - 액세스 토큰을 사용하여 사용자 정보를 가져오고, 앱의 인증 시스템에 연결합니다.

## 더 알아야할 내용

### Q. OAuth 1.0과 OAuth 2.0의 주요 차이점은 무엇인가요?

OAuth 2.0은 OAuth 1.0의 복잡성을 해결하기 위해 개발되었습니다. 주요 차이점으로는:

1. **인증 방식**: OAuth 1.0은 암호화 서명을 사용하는 반면, OAuth 2.0은 HTTPS에 의존합니다.
2. **복잡성**: OAuth 2.0은 구현이 더 단순합니다.
3. **토큰 타입**: OAuth 2.0은 액세스 토큰과 리프레시 토큰을 분리하여 사용합니다.
4. **유연성**: OAuth 2.0은 웹 앱, 모바일 앱, IoT 장치 등 다양한 클라이언트 유형에 맞는 여러 인증 흐름(Grant Types)을 제공합니다.

### Q. OpenID Connect와 OAuth 2.0의 관계는 무엇인가요?

OpenID Connect는 OAuth 2.0 위에 구축된 인증 레이어입니다. OAuth 2.0이 주로 권한 부여(Authorization)에 중점을 두는 반면, OpenID Connect는 인증(Authentication)에 초점을 맞춥니다. OpenID Connect는 ID 토큰이라는 개념을 도입하여 사용자 신원 정보를 표준화된 방식으로 제공합니다. 이를 통해 클라이언트는 "이 사용자가 누구인지" 알 수 있으며, SSO(Single Sign-On) 구현에 널리 사용됩니다.

### Q. OAuth 2.0 구현 시 보안 고려사항은 무엇인가요?

OAuth 2.0 구현 시 주요 보안 고려사항:

1. **항상 HTTPS 사용**: 모든 통신은 암호화되어야 합니다.
2. **상태(state) 파라미터 사용**: CSRF 공격 방지를 위해 상태 파라미터를 사용해야 합니다.
3. **적절한 스코프 설정**: 필요한 최소한의 권한만 요청해야 합니다.
4. **리디렉션 URI 검증**: 악의적인 리디렉션을 방지하기 위해 등록된 URI만 허용해야 합니다.
5. **토큰 만료 관리**: 액세스 토큰에 짧은 수명을 설정하고, 리프레시 토큰 관리 정책을 수립해야 합니다.
6. **클라이언트 시크릿 보호**: 클라이언트 시크릿은 서버 측에만 저장하고, 공개 클라이언트에서는 PKCE(Proof Key for Code Exchange)를 사용해야 합니다.
