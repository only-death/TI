# Q1. 웹 페이지 렌더링 방식 CSR, SSR, SSG, ISR 각각의 특징과 각 방식을 어떤 상황에 사용하면 좋을지 설명해 주세요.

## 중요 키워드

- 렌더링 방식(CSR, SSR, SSG, ISR)
- 성능 지표(TTV: Time to View, TTI:Time to Interact, FCP:First Contentful Paint, LCP:Largest Contentful Paint)
- SEO(검색 엔진 최적화)
- 하이브리드 렌더링

## Script

웹 페이지 렌더링 방식은 크게 CSR, SSR, SSG, ISR로 나눌 수 있습니다.

**CSR(Client-Side Rendering)** 은 브라우저에서 JavaScript를 통해 페이지를 동적으로 렌더링하는 방식입니다. 서버는 최소한의 HTML과 JS 파일만 전송하고, 브라우저가 JS를 실행해 DOM을 구성합니다. React 같은 라이브러리로 SPA를 구현할 때 주로 사용합니다. 장점은 초기 로드 후 페이지 전환이 빠르고 서버 부하가 적다는 것이고, 단점은 초기 로드 시간이 길고 SEO에 불리하다는 점입니다. 대시보드나 관리자 패널처럼 검색 노출이 중요하지 않고 사용자 인터랙션이 많은 애플리케이션에 적합합니다.

**SSR(Server-Side Rendering)** 은 서버에서 HTML을 완전히 생성해 클라이언트에 전송하는 방식입니다. 사용자 요청 시 서버가 데이터를 가져와 HTML을 생성하고, 브라우저는 이를 표시한 후 JS를 로드해 이벤트 핸들러를 연결합니다. 장점은 초기 로드가 빠르고 SEO에 유리하다는 것이고, 단점은 서버 부하가 크고 TTV와 TTI 사이에 지연이 있을 수 있다는 점입니다. 블로그, 뉴스 사이트처럼 콘텐츠 중심이고 검색 노출이 중요한 웹사이트에 적합합니다.

**SSG(Static Site Generation)** 는 빌드 시점에 HTML을 미리 생성해 CDN 등에 배포하는 방식입니다. 사용자 요청 시 미리 생성된 정적 파일을 제공합니다. 장점은 매우 빠른 로딩 속도와 뛰어난 SEO 성능, 서버 부하가 없다는 점이고, 단점은 동적 콘텐츠 처리에 한계가 있고 데이터 업데이트 시 재빌드가 필요하다는 점입니다. 마케팅 사이트, 문서, 포트폴리오처럼 자주 변경되지 않는 콘텐츠에 적합합니다.

**ISR(Incremental Static Regeneration)** 은 SSG의 확장으로, 특정 주기마다 페이지를 재생성하는 방식입니다. 초기에는 정적 페이지를 제공하고, 설정된 시간 간격으로 백그라운드에서 페이지를 재생성합니다. 장점은 SSG의 성능 이점을 유지하면서도 데이터 업데이트가 가능하다는 점이고, 단점은 설정된 갱신 주기에 따라 데이터가 최신 상태가 아닐 수 있다는 점입니다. 이커머스 제품 목록이나 주기적으로 업데이트되는 블로그에 적합합니다.

최근에는 Next.js와 같은 프레임워크를 통해 페이지별로 다른 렌더링 전략을 적용하는 하이브리드 접근법이 효과적입니다. 예를 들어, 자주 변경되는 데이터가 있는 페이지는 SSR로, 정적인 페이지는 SSG로, 주기적으로 업데이트되는 페이지는 ISR로 구현할 수 있습니다.

**실무 예시**

실제 프로젝트에서는 페이지의 특성에 따라 렌더링 방식을 선택합니다. 예를 들어, 이커머스 프로젝트에서는 상품 목록 페이지는 ISR로 구현해 일정 시간마다 데이터를 갱신하고, 상품 상세 페이지는 SSG로 구현해 빠른 로딩 속도를 확보할수 있고 사용자 계정 관련 페이지는 CSR로 구현해 개인화된 인터랙션을 제공할 수 있습니다
(서버 부하 감소 (사용자별 데이터 처리를 클라이언트로 분산)/ 실시간 데이터 업데이트 (장바구니, 위시리스트 등)).

### 동작 순서

#### Client-side Rendering

**1. 초기 요청:** 사용자 요청 (프론트)
**2. 최소한의 HTML전송:** 거의 내용 없고 JS 로드하는 스크립트 태그만 있는 HTML 전송 (백)
**3. JavaScript 다운로드:** 브라우저가 HTML 다운후, 참ㅈ된 JS 파일(bundle.js) 다운 (브라우저 → 서버에 bundle.js 요청 → 서버가 JavaScript 파일 전송)
**4. JavaScript 실행 (프론트)**
**5. API 데이터 요청:** JS 실행되면서 필요한 데이터 API로 요청 (브라우저 → 서버 API에 데이터 요청 → 서버가 JSON 데이터 응답)
**6. DOM 구성:** 받은 데이터로 React가 Virtual DOM을 만들고 실제 DOM에 렌더링
**7. 사용자에게 표시:** 완성된 웹페이지를 사용자가 보게됨.

#### Server-Side Rendering

1. 초기 요청: (사용자 → 서버에 요청 → 서버에서 처리 시작)
2. 서버에서 데이터 가져오기:서버가 필요한 데이터를 데이터베이스나 API에서 가져옴 (서버 → 데이터베이스/API에 요청 → 데이터 수신)
3. HTML 생성: (서버에서 React 컴포넌트를 실행하고 데이터와 함께 완전한 HTML을 생성)
4. 완성된 HTML 전송: 서버가 완전한 콘텐츠가 포함된 HTML을 클라이언트에 전송
5. 초기 표시: 브라우저가 HTML을 받자마자 사용자는 콘텐츠를 볼 수 있음 (JavaScript가 로드되기 전이라 화면만 보임) (HTML 수신 → 브라우저가 파싱 → 사용자에게 콘텐츠 표시)

**5.TTV(Time to View) 사용자가 볼 수 있는 타이밍과 TTI(Time to Interactive) 사용자가 웹페이지와 상호작용할수 있는 타이밍 사이에 갭이 생김.**
볼 수 있지만 상호작용은 아직 못함.

6. **JavaScript 다운로드:** 브라우저가 HTML을 표시한 후, JavaScript 파일을 다운로드 (브라우저 → 서버에 bundle.js 요청 → 서버가 JavaScript 파일 전송)
7. **하이드레이션(Hydration):** JavaScript가 실행되면 이미 존재하는 HTML에 이벤트 리스너 등 기능을 연결 (이 과정을 통해 정적 HTML이 상호작용 가능한 웹페이지로 변환)

#### Static Site Generation (SSG)

**1. 빌드 시점 데이터 수집:** 개발자가 빌드 명령어 실행 (프론트/서버)
**2. 정적 HTML 생성:** 빌드 과정에서 모든 페이지에 대한 완전한 HTML 파일 생성 (서버)
**3. 정적 파일 배포:** 생성된 HTML, CSS, JS 파일을 CDN이나 서버에 배포 (서버 → CDN)
**4. 사용자 요청:** 사용자가 웹사이트에 접속 (사용자 → CDN/서버에 요청)
**5. 정적 HTML 제공:** CDN이나 서버가 미리 생성된 완전한 HTML 파일을 즉시 전송 (CDN/서버 → 사용자)
**6. 초기 표시:** 브라우저가 HTML을 파싱하여 사용자에게 즉시 콘텐츠 표시 (브라우저)
**7. JavaScript 다운로드:** 브라우저가 HTML과 함께 참조된 JS 파일 다운로드 (브라우저 → CDN/서버)
**8. 하이드레이션:** JavaScript가 실행되면서 정적 HTML에 이벤트 리스너 등 인터랙티브 기능 연결 (브라우저)

특징: 사용자 요청 전에 이미 모든 HTML이 생성되어 있어 가장 빠른 초기 로딩 속도를 제공하지만, 데이터가 변경되면 재빌드 필요

Incremental Static Regeneration (ISR)
**1. 초기 빌드:** SSG와 동일하게 빌드 시점에 정적 HTML 생성 및 배포 (서버 → CDN)
**2. 사용자 요청:** 사용자가 웹사이트에 접속 (사용자 → CDN/서버에 요청)
**3. 유효성 검사:** 서버가 요청된 페이지의 캐시 유효 기간 확인 (서버)
**4. 캐시된 HTML 제공:** 유효 기간 내라면 기존 정적 HTML 즉시 제공 (CDN/서버 → 사용자)
**5. 초기 표시:** 브라우저가 HTML을 파싱하여 사용자에게 즉시 콘텐츠 표시 (브라우저)
**6. 백그라운드 재생성:** 캐시 만료된 경우, 사용자에게는 기존 페이지 제공하면서 동시에 백그라운드에서 페이지 재생성 시작 (서버)
**7. JavaScript 다운로드 및 하이드레이션:** SSG와 동일하게 진행 (브라우저)
**8. 캐시 업데이트:** 재생성 완료 후 CDN/서버의 캐시 업데이트 (서버 → CDN)
특징: SSG의 빠른 성능을 유지하면서도 설정된 주기나 조건에 따라 콘텐츠 업데이트 가능. 첫 방문자는 항상 최신 버전을 보지 못할 수 있음.

### 웹 렌더링 방식 4가지 핵심 차이점 요약

#### 1. 렌더링 위치 및 시점

CSR: 브라우저(클라이언트)에서 실시간 렌더링
SSR: 요청 시점에 서버에서 렌더링 후 클라이언트로 전송
SSG: 빌드 시점에 서버에서 미리 렌더링하여 정적 파일로 저장
ISR: 빌드 시점 + 설정된 주기마다 서버에서 재렌더링

#### 2. 초기 로드 내용

CSR: 빈 HTML + 큰 JavaScript 번들
SSR: 완전한 HTML 콘텐츠 + JavaScript 번들
SSG: 완전한 HTML 콘텐츠 + JavaScript 번들 (미리 생성됨)
ISR: 완전한 HTML 콘텐츠 + JavaScript 번들 (미리 생성됨 -> 주기적으로 갱신됨)

#### 3. 사용자 경험

CSR: 초기 로드는 느리지만 이후 페이지 전환이 빠름
SSR: 초기 콘텐츠 표시는 빠르지만 상호작용 가능해지기까지 지연 있음
SSG: 매우 빠른 초기 로드와 페이지 전환 (CDN 캐싱 활용)
ISR: SSG와 유사하게 빠르지만, 일정 주기로 콘텐츠 갱신됨

#### 4. SEO 영향

CSR: 초기 HTML이 거의 비어있어 검색 엔진이 콘텐츠 인식 어려움
SSR: 완전한 HTML이 제공되어 검색 엔진이 콘텐츠 쉽게 인식
SSG: 완전한 HTML이 제공되어 검색 엔진이 콘텐츠 쉽게 인식 (최적)
ISR: 완전한 HTML이 제공되어 검색 엔진이 콘텐츠 쉽게 인식 (주기적 갱신)

#### 5. 서버 부하

CSR: 서버는 정적 파일만 제공하므로 부하 적음
SSR: 모든 요청마다 서버에서 렌더링 작업 수행하므로 부하 큼
SSG: 빌드 시에만 렌더링하고 이후 정적 파일 제공으로 부하 최소화
ISR: 설정된 주기마다만 렌더링하므로 SSR보다 부하 적음

#### 6. 데이터 최신성

CSR: 항상 최신 데이터 표시 가능 (실시간 API 요청)
SSR: 요청 시점의 최신 데이터 표시
SSG: 빌드 시점의 데이터만 표시 (업데이트 시 재빌드 필요)
ISR: 설정된 주기에 따라 데이터 갱신 (완전한 최신성은 아님)

#### 7. 적합한 사용 사례

CSR: 대시보드, 관리자 패널, 인증이 필요한 페이지
SSR: 동적 콘텐츠가 많은 이커머스, 소셜 미디어 피드
SSG: 블로그, 마케팅 페이지, 문서 사이트
ISR: 제품 목록, 뉴스 사이트, 주기적으로 업데이트되는 블로그

## 더 알아야할 내용

### Q. CSR과 SSR의 성능 차이는 어떻게 측정할 수 있나요?

성능 차이는 Core Web Vitals 같은 지표로 측정할 수 있습니다. CSR은 TTI가 빠르지만 초기 LCP가 느릴 수 있고, SSR은 FCP와 LCP는 빠르지만 TTI가 느릴 수 있습니다. Lighthouse나 WebPageTest 같은 도구로 이러한 지표를 측정할 수 있습니다.

### Q. Next.js에서 각 렌더링 방식을 어떻게 구현하나요?

Next.js에서는 `getStaticProps`로 SSG, `getServerSideProps`로 SSR, `getStaticProps`와 `revalidate` 옵션으로 ISR을 구현합니다. CSR은 컴포넌트 내에서 `useEffect`와 같은 훅을 사용해 클라이언트 측에서 데이터를 가져오는 방식으로 구현합니다.

### Q. 하이브리드 렌더링의 구체적인 사례는 무엇인가요?

예를 들어, 블로그 플랫폼에서 메인 페이지와 카테고리 페이지는 ISR로 구현해 주기적으로 업데이트하고, 개별 블로그 포스트는 SSG로 구현해 빠른 로딩을 제공하며, 댓글 시스템은 CSR로 구현해 실시간 인터랙션을 가능하게 할 수 있습니다.

---

# 추가 궁금증

## CSR과 SSR에서의 하이드레이션 개념 차이

### 하이드레이션(Hydration)이라는 용어가 SSR에서만 사용되고 CSR에서는 사용되지 않는 이유가 뭐지?

#### 근본적인 차이점

- CSR (Client-Side Rendering): 빈 HTML → JS 다운로드 → JS가 DOM 생성 → 이벤트 리스너 연결 → 완성
- SSR (Server-Side Rendering): 완성된 HTML → 표시(사용자가 볼 수 있음) → JS 다운로드 → 하이드레이션 → 상호작용 가능

#### 하이드레이션이란?

- 하이드레이션이라는 용어는 "마른(dry) HTML에 물(water)을 주어 활성화한다"는 의미의 비유에서 옴.
  즉 CSR에서는 **처음부터 JavaScript로 DOM 요소를 생성**해 하이드레이션할 기존 HTML이 없습니다.
  SSR에서는 이미 서버에서 생성된 HTML(완성본)이 있으므로, JavaScript는 이 기존 DOM 구조를 재사용하고 여기에 기능을 더 함.

#### 왜 이 구분이 중요한가?

- 성능 차이: SSR의 하이드레이션은 기존 DOM 구조를 재사용하므로 전체 DOM을 처음부터 구축하는 것보다 효율적일 수 있음.
- 사용자 경험: SSR은 JavaScript가 완전히 로드되기 전에 콘텐츠를 표시할 수 있음 (TTV가 더 빠름) (그치만 TTI와 빈 갭이있죠?).
- 구현 복잡성: 하이드레이션은 서버와 클라이언트 간의 상태 동기화 등 고려해야 할 복잡한 문제가 있음.

**요약**
하이드레이션은 "이미 존재하는 HTML에 JavaScript 기능을 추가하는 과정"이며, 이것은 SSR에서만 발생. CSR에서는 이미 존재하는 HTML이 없기 때문에 처음부터 DOM을 생성하는 과정을 하이드레이션이라고 부르지 않는다!.

## LCP와 FCP?

### FCP (First Contentful Paint)

> FCP는 브라우저가 페이지에서 첫 번째 콘텐츠를 화면에 표시하는 시점을 측정하는 지표

- 의미: 사용자가 "뭔가 로딩되기 시작했다"고 느끼는 첫 순간
- 예시: 텍스트, 이미지, 배경색 등 페이지의 첫 요소가 표시되는 시점
- 중요성: 사용자에게 페이지가 응답하고 있다는 첫 시각적 피드백
- 좋은 수치: 1.8초 이내
- 빈 화면 → [FCP: 첫 콘텐츠 표시] → 나머지 콘텐츠 로드

### LCP (Largest Contentful Paint)

> LCP는 화면에 보이는 영역 내에서 가장 큰 콘텐츠 요소가 렌더링되는 시점을 측정하는 지표

- 의미: 페이지의 주요 콘텐츠가 사용자에게 표시되는 시점
- 예시: 메인 이미지, 헤드라인 텍스트, 주요 콘텐츠 블록
- 중요성: 페이지의 실질적인 유용성을 더 정확하게 반영 (Core Web Vitals의 일부)
- 좋은 수치: 2.5초 이내
- 빈 화면 → 첫 콘텐츠 표시 → [LCP: 주요 콘텐츠 표시] → 완전한 로드

### 렌더링 방식별 영향

- CSR: JavaScript 다운로드와 실행이 필요하므로 FCP와 LCP가 일반적으로 느림
- SSR: 서버에서 HTML을 미리 생성하므로 FCP가 빠르지만, 하이드레이션 전까지 상호작용 불가
- SSG: 미리 생성된 HTML을 즉시 제공하므로 FCP와 LCP가 매우 빠름
- ISR: SSG와 유사하게 빠른 FCP와 LCP 제공, 캐시된 콘텐츠 기준
- 이러한 지표들은 Lighthouse, Chrome DevTools, PageSpeed Insights 등의 도구로 측정할 수 있으며, 실제 사용자 경험과 SEO에 수치화에 도움.

## Core Web Vitals는 뭐야?

> Core Web Vitals은 Google이 웹사이트의 사용자 경험을 측정하기 위해 정의한 핵심 성능 지표.

- 이 지표들은 SEO에도 영향을 미치며, 웹 개발자가 사이트 성능 개선을 위해 집중해야 할 우선순위를 제시.

**Core Web Vitals는 단순한 기술적 지표가 아니라 실제 사용자 경험과 밀접한 관련이 있으며, Google 검색 엔진 순위에 직접적인 영향을 줌.**

### 현재 Core Web Vitals의 3가지 주요 지표

#### 1. LCP (Largest Contentful Paint) - 로딩 성능

- 정의: 뷰포트 내에서 가장 큰 콘텐츠 요소(이미지, 텍스트 블록 등)가 화면에 렌더링되는 시점
- 좋은 점수: 2.5초 이내
- 의미: "페이지의 주요 콘텐츠가 얼마나 빨리 로드되는가"
- 개선 방법: 서버 응답 시간 최적화, 이미지 최적화, 리소스 우선순위 지정

#### 2. CLS (Cumulative Layout Shift) - 시각적 안정성

- 정의: 페이지 로딩 중 요소들이 예상치 못하게 이동하는 정도
- 좋은 점수: 0.1 이하
- 의미: "페이지가 얼마나 시각적으로 안정적인가"
- 개선 방법: 이미지와 광고에 크기 속성 지정, 동적 콘텐츠 영역 예약

#### 3. INP (Interaction to Next Paint) - 상호작용 응답성

- 정의: 사용자 상호작용(클릭, 탭, 키보드)에 대한 웹페이지의 응답 속도
- 좋은 점수: 200ms 이하
- 의미: "사용자 입력에 얼마나 빠르게 반응하는가"
- 개선 방법: 무거운 JavaScript 실행 최적화, 이벤트 핸들러 최적화, 메인 스레드 차단 최소화
  > 참고: INP는 2024년 3월부터 FID(First Input Delay)를 대체한 새로운 지표.

### Google이 지원하는 측정 도구

- [PageSpeed Insights](https://pagespeed.web.dev/) - 실제 사용자 데이터와 실험실 환경 데이터를 모두 제공하는 종합 성능 분석 도구
- [Lighthouse](https://developer.chrome.com/docs/lighthouse/overview) - 성능, 접근성, SEO 등 웹사이트 품질을 종합적으로 평가
- [Chrome DevTools](https://developer.chrome.com/docs/devtools/performance) - 개발자를 위한 실시간 성능 디버깅 및 분석 도구
- [Search Console](https://search.google.com/search-console/about) - 웹사이트 전체의 Core Web Vitals 성능 보고서 제공
- [web-vitals JavaScript 라이브러리](https://github.com/GoogleChrome/web-vitals) - 자체 애플리케이션에 Core Web Vitals 측정 기능 통합
- [Chrome UX Report (CrUX)](https://developer.chrome.com/docs/crux) - 실제 사용자 경험 데이터 수집 및 분석

<br>

<br>

# Q2. 리액트만 사용할 때와 비교해 Next.js를 사용하는 이유에 대해 설명해 주세요.

## 중요 키워드

- 서버 사이드 렌더링(SSR)
- 정적 사이트 생성(SSG)
- 파일 기반 라우팅
- 이미지 최적화
- API 라우트

## Script

React만으로 개발할 때와 비교하여 Next.js를 사용하는 주요 이유는 다양한 렌더링 방식 지원, 개발 편의성, 성능 최적화 기능 때문입니다.

첫째, Next.js는 다양한 렌더링 방식을 지원합니다. React만 사용하면 기본적으로 CSR 방식만 가능하지만, Next.js는 SSR, SSG, ISR을 모두 지원합니다. 이를 통해 SEO가 중요한 페이지는 서버 사이드 렌더링으로, 자주 변경되지 않는 페이지는 정적 생성으로 구현할 수 있어 각 페이지의 특성에 맞는 최적의 렌더링 방식을 선택할 수 있습니다.

둘째, Next.js는 개발 편의성을 크게 향상시킵니다. 파일 기반 라우팅 시스템을 제공하여 pages 디렉토리에 파일을 생성하는 것만으로 라우트가 자동 생성됩니다. React Router 같은 추가 라이브러리 설정이 필요 없어 개발 시간을 단축할 수 있습니다. 또한 API 라우트 기능을 통해 백엔드 API를 같은 프로젝트 내에서 구현할 수 있어 풀스택 개발이 용이합니다.

셋째, Next.js는 성능 최적화 기능을 내장하고 있습니다. 자동 코드 스플리팅, 이미지 최적화, 폰트 최적화 등의 기능을 제공하여 별도의 설정 없이도 성능이 최적화된 웹 애플리케이션을 개발할 수 있습니다. 특히 Image 컴포넌트는 이미지 크기 조정, WebP 같은 최신 포맷 변환, 지연 로딩 등을 자동으로 처리해줍니다.

넷째, Next.js는 프로덕션 환경에 최적화되어 있습니다. Vercel과의 통합을 통해 배포가 간편하고, Edge 네트워크를 활용한 전 세계적인 콘텐츠 전송이 가능합니다. 또한 ISR을 통해 빌드 시간을 줄이면서도 콘텐츠를 최신 상태로 유지할 수 있습니다.

실무에서는 이러한 이점들이 개발 생산성과 애플리케이션 성능에 직접적인 영향을 미칩니다. 예를 들어, 이커머스 사이트를 개발할 때 제품 목록 페이지는 ISR로, 제품 상세 페이지는 SSG로, 장바구니는 CSR로 구현하여 각 페이지의 특성에 맞는 최적의 사용자 경험을 제공할 수 있습니다.

## 더 알아야할 내용

### Q. Next.js의 최신 버전(13 이상)에서 추가된 주요 기능은 무엇인가요?

Next.js 13 이상에서는 App Router, React Server Components, 향상된 데이터 페칭 방식, Turbopack 등이 추가되었습니다. 특히 App Router는 기존 Pages Router를 대체하며 더 유연한 레이아웃 구성과 중첩 라우팅을 가능하게 합니다.

### Q. Next.js의 단점이나 한계점은 무엇인가요?

Next.js는 학습 곡선이 있고, 특정 호스팅 환경에서는 SSR 기능을 완전히 활용하기 어려울 수 있습니다. 또한 복잡한 상태 관리가 필요한 대규모 애플리케이션에서는 추가적인 상태 관리 라이브러리가 필요할 수 있습니다.

### Q. Next.js와 다른 React 프레임워크(Gatsby, Remix 등)와의 차이점은 무엇인가요?

Gatsby는 주로 정적 사이트 생성에 초점을 맞추고 GraphQL을 기본으로 사용합니다. Remix는 중첩 라우팅과 로더 패턴을 통한 데이터 페칭에 강점이 있습니다. Next.js는 이들보다 더 범용적이고 다양한 렌더링 방식을 지원하며 더 큰 커뮤니티와 생태계를 가지고 있습니다.

## 질문 의도

- 단순히 트렌드를 따르는 것이 아니라 기술 선택에 대한 합리적인 근거를 제시할 수 있는지 평가.
- React 생태계에 대한 이해도와 함께 프로젝트 요구사항에 맞는 기술 스택을 선택할 수 있는 판단력 어필해야됨.
